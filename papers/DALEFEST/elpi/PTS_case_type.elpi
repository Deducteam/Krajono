% checks for match output type.
% PTS_inductives invokes conv_case_type

type conv1_sn term -> stack -> conversion_mode -> term -> stack -> prop.

conv1_sn T1 S1 M T2 S2 :- whd* T1 S1 (_\ T\ S\ comp1 T S M T2 S2).

type conv1_dx term -> stack -> conversion_mode -> term -> stack -> prop.

conv1_dx T1 S1 M T2 S2 :- whd* T2 S2 (_\ T\ S\ comp1 T1 S1 M T S).

type conv1 term -> stack -> conversion_mode -> term -> stack -> prop.

conv1 T1 S1 M T2 S2 :- whd* T1 S1 (_\ T\ S\ conv1_dx T S M T2 S2).

type comp1 term -> stack -> conversion_mode -> term -> stack -> prop.

% removing left product (on_case_type).
comp1 (arr W1 F1) [] (on_case_type W K S [V|SN] DX) U2 S2 :- !,
  pi x\ val x W1 V NF => conv1_sn (F1 x) [] (on_case_type W K S SN DX) U2 S2.

% xi for right product (on_case_type).
comp1 (arr W1 F1) [] (on_case_type W K S [] [_|DX]) (arr W2 F2) [] :- !,
  conv W1 W2,
  pi x\ conv1 (F1 x) [] (on_case_type W K S [] DX) (F2 x) [].

% final checks (on_case_type).
comp1 (sort YI) [] (on_case_type W1 K SN1 [] []) (arr W2 F2) [] :-
  whd* W2 []
    (_\ W\ S\ sigma SN\ sigma DX\
      W = W1, split S K SN DX, forall2 SN1 SN conv
    ),
  pi x\ conv1_dx (sort YI) [] on_case_proj (F2 x) [].

% projectability (on_case_proj)
% note: we do nothing for now ...
comp1 (sort YI) [] on_case_proj (sort YO) [] :- true.

type conv_case_type term -> term -> int -> stack -> stack -> term -> prop.

conv_case_type T1 W K SN DX T2 :- conv1 T1 [] (on_case_type W K SN SN DX) T2 [].

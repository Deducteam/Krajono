% PTS extension with inductive types and recursive functions
% accumulate after PTS_machine.elpi, and before PTS_global.elpi

% match W U V A: match V with constructors of ind. type W, and select branch in A of type U
type match term -> term -> term -> list term -> term.

% match_trame W U A P: stack frame for match
type match_trame term -> term -> list term -> stack -> stack.

% HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% we need to compare match frames on stacks
forall2 (match_trame W U1 A1 P1) (match_trame W U2 A2 P2) F :-
 F U1 U2, forall2 A1 A2 F, forall2 P1 P2 F.

% Whd followed by continuation and machine unwinding.
type whd_continue_unwind term -> (term -> stack -> term -> stack -> prop) -> term -> prop.
whd_continue_unwind N K NF :-
 whd* N [] (l \ t1 \ s1 \ sigma t2 \ sigma s2 \ sigma TS \ K t1 s1 t2 s2, unwind_stack s2 t2 TS, put_abbr l TS NF).

% REDUCTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type get_branch int -> stack -> term -> stack -> stack -> prop.
/* stack, constructor => branch, rear stack, front stack */ 
get_branch (match_trame _ _ A P) J T P [] :- nth A J T.
get_branch [V|P] J T P1 [V|P2] :- get_branch P J T P1 P2.

% wind for match
whd1 (match W U V A) P C :- C [] V (match_trame W U A P).

% iota for match
% note: the left arguments must be removed
whd1 T1 P1 C :- get_constructor T1 J K, !,
                get_branch P1 J T2 P A, split A K SN DX, append DX P P2,
                C [] T2 P2.

% unwind for match
unwind_stack (match_trame W U A P) V1 V2 :- unwind_stack P (match W U V1 A) V2.

% GLOBAL DELTA EXPANSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

is_constructor V P V P :- get_constructor V _ _.

unwind_whd_to_constructor V1 V2 :- whd_continue_unwind V1 is_constructor V2.

% check constructor before expanding fixpoint
expand T1 P1 P2 :- get_fixpoint T1 L, !,
                   subst P1 L unwind_whd_to_constructor P2.

% TYPING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

check_branch U K SN V0 T0 :-
 of V0 W0, of T0 U0,
 fold_left SN app V0 SNV0,
 conv_match_branch W0 SNV0 K SN U U0.

mk_out_type W U V TS W S U DXV :-
 get_inductive W K VS, split S K SN DX,
 of W T1, of U T2,
 conv_match_type T1 W K SN DX T2,
 forall2 VS TS (check_branch U K SN),
 append DX [V] DXV.

% not complete, we do not check allowed sort elimination
of (match W U V A) X :- !,
 of V W1, whd_continue_unwind W1 (mk_out_type W U V A) X.

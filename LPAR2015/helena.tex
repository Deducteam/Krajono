\subsection{A Relevant Test Case: the ``Grundlagen'' Verified}
\label{grundlagen}

As a relevant test case for \elpi,
we implemented in the \frag{}
a validator for the latest version of the formal system $\lambda\delta$,
and used this validator to verify the
``Grundlagen'' \cite{Jut79} translated in a Pure Type System
\cite{Brn92}.

The formal system $\lambda\delta$ \cite{lambdadeltaJ1},
improved in \cite{lambdadeltaJ2a,lambdadeltaJ3a},
is a framework that embeds
some former typed $\lambda$-calculi including 
$Aut-QE$, the Automath dialect in which the ``Grundlagen'' was
originally written, and Pure Type Systems like $\lambda C$.

%FG: comment this paragraph in case of need
Current verification algorithms for typed systems follow
a well-established pattern prescribing a reduction
machine to compute weak head normal forms, a comparator to assert
convertibility by levels, and a checker responsible for type inference.
The verification algorithm for $\lambda\delta$ 
deviates slightly from this pattern in that
type checking is replaced by validation, and in that
type inference is delegated to the (extended) reduction machine. 
The performance benefits of this approach are documented in
\cite{lambdadeltaJ3a}.
We wish to recall that type checking a term means
asserting that this term has a specified type, whereas
validating a term means asserting that this term has 
some unspecified type.

A validator for $\lambda\delta$, named Helena,
has been implemented in Caml,
and our \lp{} implementation follows it closely.
Nevertheless, the \lp{} code is much simpler that the
corresponding Caml code (441 lines), and consists of just 52 clauses.
In particular, the built-in environment of the \lp{} engine is used in place of
the environments explicitly implemented in Caml. 

The translated ``Grundlagen'' is a theory comprising 
32 declarations and 6879 definitions, for a total of 6911 items.
Each item is a term to be verified, written in the raw syntax of
$\lambda C$ with constants type casts. The sort $\square$ never
appears explicitly and the sorts \emph{set} or \emph{prop}
are used in place of the sort $\ast$.

The term in each definition is a type cast in a 
context of $\lambda$-abstractions corresponding to the ``block openers''
of $Aut-QE$.
On the other hand, the term in each declaration (that is, a type) is
given in a context of $\Pi$-abstractions.

Overall, the tree representation of these terms consists of
754579 nodes.
This huge amount of data seems to overwhelm the capabilities of Teyjus,
which is limited by design restrictions.
Therefore, as of now, we can verify with this system
just the first 255 items of the ``Grundlagen''.

On the other hand, we can present the full ``Grundlagen'' to Coq
\cite{lambdadeltaJ3a}.

In the tables below, we compare preprocessing (Pre), and verification
(Ver) for Helena, \elpi, Teyjus, and Coq.
Depending on the system,
verification refers to validation, type checking, and (bytecode) execution,
while preprocessing accounts for parsing, internalization, compilation,
linking, and refinement.

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\multicolumn{3}{|c|}{User time range (s) for 31 runs (255 items only)}\\
\hline
Task & \elpi               & Teyjus              \\
\hline
Pre  & from 00.07 to 00.09 & from 03.24 to 03.31 \\
\hline
Ver & from 00.20 to 00.22 & from 02.13 to 02.26 \\
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\multicolumn{4}{|c|}{User time range (s) for 31 runs (all items)}\\
\hline
Pre + Ver  & Helena               & \elpi               & Coq                 \\
\hline
compiled    & from 01.14 to 01.18 & not applicable      & from 24.26 to 24.43 \\
\hline
interpreted & from 08.73 to 08.77 & from 27.52 to 27.82 & from 94.18 to 95.78 \\
\hline
\end{tabular}
\end{center}

Specification "big_step".
Set instantiations on.

Kind constant type.
Kind formula type.

Kind flist type.
Type fnil flist.
Type fcons formula -> flist -> flist.

Kind sequent type.
Type pair flist -> formula -> sequent.

Kind slist type.
Type snil slist.
Type scons sequent -> slist -> slist.

/*
Define is_in_our_syntax : o -> prop :=
   is_in_our_syntax ttrue
 ; is_in_our_syntax (aand t1 t2) :=
     is_in_our_syntax t1, is_in_our_syntax t2
 ; is_in_our_syntax (pi x : o \ F x).  := ... . 

Theorem test:
 forall Ctx G F,
   is_in_our_syntax G ->
   { Ctx , [G] |- F } -> steps snil (pair Ctx F) snil.

Theorem test:
 forall Ctx F,
   is_in_our_syntax F ->
   { Ctx |- F } -> steps snil (pair Ctx F) snil.
 induction on 1. intros. case H1.
*/

Define sappend : slist -> slist -> slist -> prop by
  sappend snil X X
; sappend (scons X L1) L2 (scons X L3) := sappend L1 L2 L3.

Define match : formula -> formula -> formula -> prop by
  match (ppi F) Pred Body := exists X, match (F X) Pred Body
; match (aand F1 F2) Pred Body :=
    match F1 Pred Body /\ match F2 Pred Body
; match (iimp Body Pred) Pred Body.

Define look_in_prog: flist -> formula -> formula -> prop by
/*  look_in_prog Prog (iimp F1 F2) ClauseTail :=
    look_in_prog (fcons F1 Prog) F2 ClauseTail */
; look_in_prog (fcons ClauseHead Tl) Pred ClauseTail := 
    match ClauseHead Pred ClauseTail
; look_in_prog (fcons ClauseHead Tl) Pred G := look_in_prog Tl Pred G.

Define step : flist -> sequent -> slist -> prop by
  step Prog (pair Ctx ttrue) snil
; step Prog (pair Ctx (aand F1 F2)) (scons (pair Ctx F1) (scons (pair Ctx F2) snil))
; step Prog (pair Ctx (oor F1 F2)) (scons (pair Ctx F1) snil)
; step Prog (pair Ctx (oor F1 F2)) (scons (pair Ctx F2) snil)
; step Prog (pair Ctx (iimp F1 F2)) (scons (pair (fcons F1 Ctx) F2) snil)
% ; nabla x, step Prog (pair Ctx (pi x : o \ F x)) (scons (pair Ctx (F x)) snil)
; nabla x, step Prog (pair Ctx (ppi F)) (scons (pair Ctx (F x)) snil)
; step Prog (pair Ctx (ssigma F)) (scons (pair Ctx (F X)) snil)
; step Prog (pair Ctx Pred) (scons (pair Ctx ClauseBody) snil) :=
    look_in_prog Ctx Pred ClauseBody \/
    look_in_prog Prog Pred ClauseBody.

Define smem: sequent -> slist -> prop by
  smem S (scons S Tl)
; smem S (scons A Tl) := smem S Tl.

Define flist_mem : formula -> flist -> prop by
  flist_mem S (fcons S Tl)
; flist_mem S (fcons A Tl) := flist_mem S Tl.


Define provable : flist -> sequent -> prop by
  provable Prog Seq :=
   exists AndL,
    step Prog Seq AndL /\
    (forall Seq2, smem Seq2 AndL -> provable Prog Seq2).

Theorem match_ok:
 forall Ctx Clause Head Body,
   match Clause Head Body ->
   { Ctx |- (fla_to_o Body) } ->
   { Ctx, (fla_to_o Clause) |- (fla_to_o Head) }. 
 induction on 1. intros. case H1.  
  % pi
  apply IH to H3 H2. skip. % not possible
  % and 
  apply IH to H3 H2. apply IH to H4 H2. skip. % only true for &, not aand :-(
  % imp
  backchain IH. skip. % it is an axiom under * 
    

Define to_olist : flist -> olist -> prop by
  to_olist fnil nil
; to_olist (fcons X Lf) ((fla_to_o X)::Lo) := to_olist Lf Lo.
%                        extend it
                         

Theorem in_flist:
 forall X Y L, flist_mem Y L -> flist_mem Y (fcons X L). 
  induction on 1. intros.
  case H1. search.
  
  apply IH to H2 with X = A.  
  case H3.
  apply IH to H2 with X = A.  
  search.

  apply IH to H2 with X = A.  
  search.

Theorem look_in_prog_ok:
 forall Ctx1 Ctx2 Ctx222 Head Body,
   look_in_prog Ctx1 Head Body ->
   to_olist Ctx2 Ctx222 ->
   (forall X, (flist_mem X Ctx1) -> (flist_mem X Ctx2)) ->
   exists Clause Ctx3 Ctx333,
    Ctx3 = (fcons Clause Ctx2) /\
    Ctx333 = (fla_to_o Clause)::Ctx222 /\
    (flist_mem Clause Ctx1) /\
   ({Ctx222 |- (fla_to_o Body) } -> { Ctx333 |- (fla_to_o Head) }).

   induction on 1. intros. case H1. 

   exists ClauseHead. exists (fcons ClauseHead Ctx2). 
   exists (fla_to_o ClauseHead)::Ctx222.
   split.  search. search. search. intros. 
   apply match_ok to H4 H5. search.

   apply IH to H4 H2 _. intros.
   backchain H3.
   exists Clause. exists (fcons Clause Ctx2). 
   exists (fla_to_o Clause)::Ctx222. split. search. search.
   backchain in_flist. search.

Theorem add_list:
 forall X Lf Lo, to_olist Lf Lo -> to_olist (fcons X Lf) ((fla_to_o X) :: Lo).
  induction on 1. intros. case H1. search.
  apply IH to H2 with X = X1. search.

Theorem clause_in_list:
 forall Clause Ctx Ctx2, to_olist Ctx Ctx2 -> flist_mem Clause Ctx   -> (member (fla_to_o Clause) Ctx2).  
  induction on 1. intros.  
  case H1. case H2. backchain IH. backchain add_list.

Theorem provable_big_ok:
 forall Ctx Ctx2 F, provable fnil (pair Ctx F) -> to_olist Ctx Ctx2 -> { Ctx2 |- (fla_to_o F) }.
 induction on 1. intros. case H1. case H3.  
  % true
  search. 
  % aand.
  unfold aand. backchain IH. backchain H4. 
  backchain IH. backchain H4.
  % oor
  unfold oor1. backchain IH. backchain H4.
  % oor
  unfold oor2. backchain IH. backchain H4.
  % =>
  unfold iimp. backchain IH. backchain H4. 
  % ppi
  unfold ppi. backchain IH. permute (n1 n2) H4. backchain H4. 
  % ssigma
  unfold ssigma. 
    exists X. backchain IH. backchain H4. 
  % backchain
  case H5.            
    apply look_in_prog_ok to H6 H2 _. 
    apply H8 to _. backchain IH. backchain H4. 
    assert { Ctx2 |- fla_to_o Clause }. % from H2 and H7
    apply clause_in_list to H2 H7.
    search.
    cut H9 with H10. search.
    apply look_in_prog_ok to H6 H2 _. intros. case H7. case H7.

Define stepl : flist -> slist -> slist -> prop by
  stepl Prog (scons Seq AndL) AndLO :=
    exists NewAndL,
      step Prog Seq NewAndL /\ sappend NewAndL AndL AndLO. 

Define steps : flist -> slist -> slist -> prop by
  steps Prog AndL AndL
; steps Prog AndLI AndLO :=
   exists AndL, stepl Prog AndLI AndL /\ steps Prog AndL AndLO.

Theorem smem_sappend_l:
 forall X L1 L2 L3,
   sappend L1 L2 L3 -> smem X L1 -> smem X L3.
 induction on 1. intros. case H1.
   case H2.
   case H2. search. apply IH to H3 H4. search.

Theorem smem_sappend_r:
 forall X L1 L2 L3,
   sappend L1 L2 L3 -> smem X L2 -> smem X L3.
 induction on 1. intros. case H1.
   search.
   apply IH to H3 H2. search.

Theorem small_provable:
 forall Seq AndL,
  steps fnil AndL snil ->
  smem Seq AndL ->
  provable fnil Seq.  
 induction on 1. intros. case H1.
  % snil
  case H2.
  % scons
  case H3. case H2.
   % Seq = Seq1
   unfold. exists NewAndL. split. search. intros.
   backchain IH. backchain smem_sappend_l.
   % Seq in tail
   backchain IH. backchain smem_sappend_r.

Theorem small_big_ok:
 forall Ctx F Ctxo,
  steps fnil (scons (pair Ctx F) snil) snil ->
  to_olist Ctx Ctxo -> { Ctxo |- fla_to_o F }.
intros. apply small_provable to H1 _. backchain provable_big_ok.



accumulate logic.
accumulate list.

% Requires the accumulation of PTS_abbr_typing.

macro @stack :- list term.
macro @vars :- list term.
macro @whd_continuation :- @vars -> term -> @stack -> prop.

%%%%%%%%%%%%%%%% Reduction

type whd1 term -> @stack -> @whd_continuation -> prop.
% KAM-like rules in CPS style
whd1 (app M N) S K :- !, K [] M [N|S].
whd1 (lam T F1) [N|NS] K :- !, pi x \ val x T N _NF => K [x] (F1 x) NS.
whd1 (abbr T N F1) NS K :- !,
 % CSC: scommentando le righe dopo cambia il comportamento di ELPI
 % $print "WH1" (abbr T N F1) NS K,
 pi x \ val x T N _NF =>
 % CSC: scommentando le righe dopo cambia il comportamento di ELPI
 % $print "WH2" (K [x] (F1 x) NS),
 K [x] (F1 x) NS.
whd1 X S K :- val X _ N NF, if (is_flex NF) (whd_unwind N NF), !, K [] NF S.

type whd*_inner @whd_continuation -> @vars -> @whd_continuation.
type whd*_outer @whd_continuation -> @whd_continuation.
type whd* term -> list term -> @whd_continuation -> prop.
% Reflexive, transitive closure
whd*_inner K VL1 VL2 T2 S2 :- append VL1 VL2 VL, K VL T2 S2.
whd*_outer K VL1 T1 S1 :- whd* T1 S1 (whd*_inner K VL1).
whd* T1 S1 K :- whd1 T1 S1 (whd*_outer K), !.
whd* T1 S1 K :- K [] T1 S1.

%%%type whd** term -> list term -> @whd_continuation -> list term -> prop.
%%%type whd* term -> list term -> @whd_continuation -> prop.
%%%% KAM-like rules in CPS style
%%%whd** (app M N) S K L :- !, whd** M [N|S] K L.
%%%whd** (lam T F1) [N|NS] K L :- !, pi x \ val x T N _NF => whd** (F1 x) NS K [x|L].
%%%whd** (abbr T N F1) NS K L :- !, pi x \ val x T N _NF => whd** (F1 x) NS K [x|L].
%%%whd** X S K :- val X _ N NF, if (is_flex NF) (whd_unwind N NF), !, whd** NF S K L.
%%%whd** T S K L :- K L T S.
%%%whd* T S K :- whd** T S K [].

type whd_unwind_inner term -> @whd_continuation.
type whd_unwind term -> term -> prop.
% Whd followed by machine unwinding.
whd_unwind_inner NF L T S :- unwind_stack S T TS, put_abbr L TS NF.
whd_unwind N NF :- whd* N [] (whd_unwind_inner NF).

type match_sort_inner @univ -> @whd_continuation.
type match_sort term -> @univ -> prop.
%
match_sort_inner I _ T S :- T = sort I, S = [].
match_sort T I :- whd* T [] (match_sort_inner I).

type match_arr_inner term -> (term -> term) -> @whd_continuation.
type match_arr term -> term -> (term -> term) -> prop.
%
match_arr_inner A F L T S :-
  S = [],
  T = arr A' F',
  put_abbr L A' A,
  pi x \ put_abbr L (F' x) (F x).
match_arr T A F :- whd* T [] (match_arr_inner A F).

type unwind_stack @vars -> term -> term -> prop.
% unwind_stack takes an head and a stack and decodes them to a term
unwind_stack [] T T.
unwind_stack [X|XS] T O :- unwind_stack XS (app T X) O.

% put_abbr takes a list of variables and a term and wraps the latter
% with local definitions for the variables in the list
put_abbr [] NF NF.
put_abbr [X|XS] I (abbr T N K) :- val X T N _, put_abbr XS I (K X).

%%%%%%%%%%%%%%%% Conversion

type lt @univ -> @univ -> prop.

type conv term -> term -> prop.
type sub term -> term -> prop.

type comp_sn term -> @stack -> eq_or_leq -> @whd_continuation.
type comp_dx term -> @stack -> eq_or_leq -> @whd_continuation.
type comp term -> @stack -> eq_or_leq -> term -> @stack -> prop.

type eq eq_or_leq.
type leq eq_or_leq.

conv T1 T2 :- comp T1 [] eq T2 [].
sub T1 T2 :- comp T1 [] leq T2 [].

% fast path + axiom rules
comp T S _ T S :- !.
% cumulativity
comp (sort I) [] leq (sort J) [] :- lt I J.
% congruence + fast path rule
comp X S1 _ X S2 :- forall2 S1 S2 conv, !.
% congruence rules
comp (lam T1 F1) [] eq (lam T2 F2) [] :- conv T1 T2, pi x \ conv (F1 x) (F2 x).
comp (arr T1 F1) [] D (arr T2 F2) [] :- conv T1 T2, pi x \ comp (F1 x) [] D (F2 x) [].
% reduction rules
comp T1 S1 D T2 S2 :- whd1 T1 S1 (comp_sn T2 S2 D), !.
comp T1 S1 D T2 S2 :- whd1 T2 S2 (comp_dx T1 S1 D), !.
% continuations
comp_sn T2 S2 D _ T1 S1 :- comp T1 S1 D T2 S2.
comp_dx T1 S1 D _ T2 S2 :- comp T1 S1 D T2 S2.

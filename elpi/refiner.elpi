% vim: syntax=prolog:

% enabling/disabling this will change the program hence the value of the
% counters of the tracing mechanism of elpi
debug :- false.

/************************* logic ************************/

true.
not A :- A, !, false.
not A.

/************************* utilities ************************/

% print only when debug is true and annotate with the value of the "run" counter
dbgpp S T :- debug, !, $counter ["run",N], $printl ["run:",N,": ",S,T,"\n"].
dbgpp S T.

% always print
pp S T :- $printl [S,T,"\n"].

/************************* refiner ************************/

% this is not going to be run always, since hyp clases will have precedence
% over this rule.  Still one gets a good value for further investigation
% using: ./elpi -trace-on -trace-at run 1673 1700 -trace-only 'run' refiner.elpi
% that will print all goals processed
of M TY T :- dbgpp "" (of M TY T), false.

% bi-directional rule for lam
of (lam S F) TY (lam S2 F2) :-
  not($is_flex TY),
  TY = prod S2 T, % CSC: whd missing here!
  !,
  of S set S3,
  unify S2 S3,
  (pi x\ of x S3 x => unify x x => of (F x) (T x) (F2 x)).

% ideally each rule should take care of dealing with bi-directionality
of T TY W :- not($is_flex TY), !, of T TY1 W1, coerce W1 TY1 TY W.

coerce T TyA TyE W :- dbgpp "" (coerce T TyA TyE W), false.
coerce T TyA TyE W :- unify TyA TyE.
coerce T (app (lam _ F) N) TyE W :- % CSC: whd required because we infer redexes
 subst F N TyA, coerce T TyA TyE W.
coerce T (atom nat) (atom z) (app (atom nat_to_z) T).

of hole TY T :- delay TY (of TY set TY), delay T (of T TY T).

of (lam S F) (prod S2 T) (lam S2 F2) :-
  of S set S2,
  (pi x\ of x S2 x => unify x x => of (F x) (T x) (F2 x)).

of (prod S F) set (prod S2 F2) :-
  of S set S2,
  (pi x\ of x S2 x => unify x x => (of (F x) (T x) (F2 x), unify (T x) set)).

of (app M1 N1) Z (app M2 N2) :-
    of M1 TM1 M2,
    of (prod hole x\hole) _ TM2,
    unify TM1 TM2,
    TM2 = prod TY1 F,
    of N1 TY1 N2,
    subst F N2 Z.

of (atom ID) T (atom ID) :- env ID T.

env zero (atom nat).
env succ (prod (atom nat) (x \ (atom nat))).
env plus (prod (atom nat) (x\ prod (atom nat) (y\ (atom nat)))).
env nat set.
env z set.
env nat_to_z (prod (atom nat) (x\ atom z)).
env vect (prod (atom nat) (x\ set)).
env vnil (app (atom vect) (atom zero)).
env vcons (prod (atom nat) (n\ prod (app (atom vect) n) (w\ app (atom vect) (app (atom succ) n)))).

of set set set.

% CSC: non dependent recursion
of (rec Rty N Base Step) Rty2 (rec Rty2 N2 Base2 Step2) :-
  of Rty set Rty2,
  of N (atom nat) N2,
  of Base Rty2 Base2,
  of Step (prod (atom nat) n\ prod Rty2 acc \ Rty2) Step2.

/************************ retype *************************/
rof T TY :- dbgpp "ritipo " (il termine T ":" TY), of T TY _, !.
rof T TY :- dbgpp "ritipaggio fallito! " (rof T TY), $abort "1".

/************************* subst ************************/
subst Where What Out :- Where What = Out.

/************************* unify ************************/

restrict X :- pi c\ pi d\ X c = X d.

% CSC: QUESTO CODICE E' ROTTO PERCHE' LA RESTRICT NON SI PUO' PIU' FARE COSI'!
uall2 L1 L2 H :- dbgpp "" (uall2 L1 L2 H), false.
uall2 [] [] H.
uall2 [X|XS] [Y|YS] H :- unify X Y, !, pi x\ unify x x => uall2 XS YS (H x).
uall2 [X|XS] [Y|YS] H :- restrict H, pi x\ uall2 XS YS (H x).

% delift M L Y instantiates the output M s.t. @M L = Y
delift0 M L Y :- dbgpp "" (delift M L Y), false.
delift0 M [] Y :- delift_aux M Y.
delift0 M [X|XS] Y :- rof X T,
  pi c\ of c T c => binds c X => delift0 (M c) XS Y.

binds A B :- dbgpp "" (binds A B), false.

delift ML M L Y :-
  dbgpp "<<<< assegno: " (valore Y alla meta M con subst L),
  % CSC: BUG, IL CODICE COMMENTATO QUA SOTTO E' MAL TIPATO PERCHE' M E' DI
  % META-TIPO FUNZIONALE
  resume ML (delift0 M L Y), %pp "VERIFICO " M, of M _ _, pp "VERIFICATO " M),
  dbgpp "assegnato >>>> " M.

delift_aux M Y :- dbgpp "" (delift_aux M Y), false.

%mimic (i.e. copy-clauses) with pruning
delift_aux M (#N L) :- !,
  delift_subst L L1,
  mkhole M1 L1, mkapp M1 L1 M,
  dbgpp "fresh meta with delifted/pruned subst: " M.
mkhole M [] :- of hole _ M.
mkhole M [X|XS] :-
  rof X TY,
  pi x\ of x TY x => unify x x => mkhole (M x) XS.
mkapp X [] X.
mkapp X [Y|YS] W :-mkapp (X Y) YS W.

% projection
delift_aux M Y :- binds V X, dbgpp "trying " (grab X as V), unify X Y, M=V.

%mimic (i.e. copy-clauses)
delift_aux (atom A) (atom A).
delift_aux set set.
delift_aux (app M1 M2) (app N1 N2) :- delift_aux M1 N1, delift_aux M2 N2.
delift_aux (lam S1 F1) (lam S2 F2) :-
 delift_aux S1 S2, pi c\ unify c c => delift_aux c c =>
  of c S1 c => delift_aux (F1 c) (F2 c).
delift_aux (prod S1 F1) (prod S2 F2) :-
 delift_aux S1 S2, pi c\ unify c c => delift_aux c c =>
  of c S1 c => delift_aux (F1 c) (F2 c).
delift_aux (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  delift_aux A1 A2, delift_aux B1 B2, delift_aux C1 C2, delift_aux D1 D2.

% delift_subst delifts or prunes items in L
delift_subst L W :- dbgpp "" (delift_subst L W), false.
delift_subst [] [].
delift_subst [X|XS] [A|XS1] :- delift_aux A X, ! /*red*/, delift_subst XS XS1.
delift_subst [_|XS] XS1 :- delift_subst XS XS1.


unif A M N :- dbgpp "" (unif A M N), false.

/* M=M */
unif ff (#M L1) (#M L2) :- !, uall2 L1 L2 M.
unif ff (@M L) (#M L) :- !.
unif ff (#M L) (@M L) :- !.
unif ff (@M L) (@M L) :- !.

/* flex=term */
unif ff T N :-
 T = #M L,
 dbgpp " ----> ritipo " N,
 rof N TN,
 dbgpp " ----> ritipo " T,
 rof T TN,
 delift T M L N.
/* term=flex */
unif ff N T :-
 T = #M L,
 dbgpp " ----> ritipo " N,
 rof N TN,
 dbgpp " ----> ritipo " T,
 rof T TN,
 delift T M L N.

%unif _ (@M _) _ :- !, false.
%unif _ _ (@M _) :- !, false.

%CSC: BUG HERE, VECCHIO CODICE
/* lambda-intro on the fly */
unif _ T (app H A) :-
 H = @M L1, !, rof A Ty, unif ff H (lam Ty G), unif ff T (app H A).


/* reflexive closure + heuristic for == */
/*unif ff _ T T :- !.*/
unif ff set set :- !.
unif ff (atom A) (atom A) :- !.

/* contextual closure + heuristic */
unif ff (app H A) (app K B) :- unify H K, unify A B.

/* contextual closure */
unif ff (lam S F) (lam T G) :-
  !, unify S T, pi x\ of x S x => unify x x => unify (F x) (G x).

unif ff (prod S F) (prod T G) :-
  !, unify S T, pi x\ of x S x => unify x x => unify (F x) (G x).

/* contextual closure + heuristic */
unif ff (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  unify A1 A2, unify B1 B2, unify C1 C2, unify D1 D2.

/* beta */
unif _ (app L M) X :-
  L = lam _ F, !,
  dbgpp "beta redex " (head F arg M),
  subst F M Y,
  dbgpp "ridotto " Y,
  unify Y X.

/* delta */
unif _ (atom ID) B :- body ID B.

/* delta */
body plus (lam (atom nat)
             (n\ (rec (prod (atom nat) (x\ (atom nat))) n
                   (lam (atom nat) (x\ x))
                   (lam (atom nat) m\ lam (prod (atom nat) (x\ (atom nat))) acc\
                      lam (atom nat) (n\ app (atom succ) (app acc n)))))) :- !.
/* iota */
unif _ (rec _ N _ _) _ :- $is_flex N, !/*red*/, fail.
unif _ (rec _ N B R) X :- N = atom zero, !, unify B X.
unif _ (rec T N B R) X :-
  N = app (atom succ) M, !, unify (app (app R M) (rec T M B R)) X.

/* symmetric */
unif ff A B :- unif tt B A.

unify A B :- unif ff A B.

/******************** Tactics **********************/

tacsem i     (lam hole (x\ hole)).
tacsem (a M) (app M hole).
tacsem (h N) (var N).
tacsem (r M) M.

/******************** GUI **************************/

test_unify A B TA2 :-
  dbgpp "---------> " (of A TA A1),
  of A TA A1,
  dbgpp "---------> " (of B TB B1),
  of B TB B1,
  dbgpp "========== " (unify TA TB),
  unify TA TB,
  dbgpp "========== " (unify A1 B1),
  unify A1 B1.

of (var N) T M :- hyp N X, of X T M.

step_in N (decl TY F) :-
  pi x\ of x TY x => copy x x => unify x x => hyp N x => (
  M = ss N,
  dbgpp "" (hyp N TY),
  step_in M (F x), !).

read_tac T :-
  $print "\ntactic> ",
  $read S,
  $parse [S,T], !.
read_tac T :- $print "\nparse error\n", read_tac T.

step_in N (goal M MTY) :-
  dbgpp "=========\n" MTY,
  read_tac T1,
  dbgpp "running " T1,
  tacsem T1 P,
  dbgpp "got term " P,
  of P TP P1,
  dbgpp "of type " TP,
  unify TP MTY,
  $print "unifies with goal!\n\n",
  P1 = M, !.

step_in N G :- $print "\ntactic error\n", step_in N G.

step nil :- $print "\nProof completed.\n".
step [G|GS] :-
  step_in zz G,
  step Sig.
  
claim Claim P1 :-
  of Claim set Claim1,
  of hole THole P,
  unify THole Claim1,
  step Sig.

/* ======================================================================== */

% usage:
% > test _          runs all tests, only first solution of each
% > test t2         runs only test t2, only first solution of t2
% > solutions t2    generates all solutions of t2

suite TEST t1 :- % runnin of twice in a row should work
  TEST = (of (lam (atom nat) x\ hole) TY T, of T TY1 T1, TY1=TY, T1=T).
suite TEST t2 :- % typing a pi
  TEST = (of (prod (atom nat) x\ hole) TY T).
suite TEST t3 :- % meta/meta unif w pruning: ?X[] = ?Y[v]
  TEST = (of (lam (atom nat) x\ app (atom succ) hole) TY T,
          of (app (atom succ) hole) TY1 W,
          pp "non-ristretto " T, unify (app T (atom zero)) W,
          pp "ristretto " T).
suite TEST t4 :-
  TEST = (of hole TY1 T1, unify TY1 (atom nat), of hole TY2 T2, unify TY2 set).
% alla seconda soluzione crasha
suite TEST t5 :-
  TEST = (of (lam hole (x\ x)) (prod (atom nat) x\ atom z) X).
% non fa piu' intro on the fly
suite TEST t6 :-
  TEST = (of hole _ X, unify (app X (atom zero)) (atom zero)).

run1 T :- pp "INFO: running " T, T, !, pp "INFO: success " T.
run1 T :- pp "ERROR: failure " T.
test N :- suite T N, run1 T, false.
test _ :- $print "INFO: all tests run\n".
run T :- pp "INFO: running " T, T.
run T :- pp "ERROR: failure " T.
solutions N :- suite T N, run T.

% vim: syntax=prolog:

/* ============================== logic =================================== */

true.
not A :- A, !, false.
not A.

/* ============================== utils =================================== */

% enabling/disabling this will change the program hence the value of the
% counters of the tracing mechanism of elpi
debug :- false.

% print only when debug is true and annotate with the value of the "run" counter
dbgpp T :- debug, !, $counter ["run",N], $printl ["run:",N,": "|T].
dbgpp _.

% print with a new line at the end
pp T :- $printl T.

assert P :- P, !.
assert P :- pp ["assert failure: ",P], $abort "1".

if B T _ :- B, !, T.
if _ _ E :- E.

or A _ :- A.
or _ B :- B.

rev L Lr :- L dummy@ = @dummy Lr.

spy P :- dbgpp ["enter ",P], P, !, dbgpp ["exit ",P].
spy P :- dbgpp ["fail ",P].

/* ========================== type inference ============================== */

% this is not going to be run always, since hyp clases will have precedence
% over this rule.  Still one gets a good value for further investigation
% using: ./elpi -trace-on -trace-at run 1673 1700 -trace-only 'run' refiner.elpi
% that will print all goals processed
:of-pp < _:
of M TY T :- dbgpp [of M TY T], false.

% bi-directional rule for lam
of (lam S F) TY (lam S2 F2) :-
  not($is_flex TY),
  TY = prod S2 T, % CSC: whd missing here!
  !,
  of S set S3,
  unify S2 S3,
  (pi x\ (of x S3 x :- !) => unify x x => of (F x) (T x) (F2 x)).

% fresh A W creates a W of level zero applied to all the local subst of A
fresh (?HD L) W :- !, $zero_level W1, mkapp W1 L W.
fresh _ _.
% ideally each rule should take care of dealing with bi-directionality
of T TY W :- not($is_flex TY), !,
%  fresh W TY1, fresh W W1,
  of T TY1 W1, coerce W1 TY1 TY W.

coerce T TyA TyE W :- dbgpp [coerce T TyA TyE W], false.
coerce T TyA TyE T :- unify TyA TyE.
coerce T (app (lam _ F) N) TyE W :- % CSC: whd required because we infer redexes
 subst F N TyA, coerce T TyA TyE W.
coerce T (atom nat) (atom z) (app (atom nat_to_z) T).

of hole TY T :- delay TY (of TY set TY), delay T (of T TY T).

of (lam S F) (prod S2 T) (lam S2 F2) :-
  of S set S2, (pi x\ (of x S2 x :- !) => unify x x => of (F x) (T x) (F2 x)).

of (prod S F) set (prod S2 F2) :-
  of S set S2,
  (pi x\ (of x S2 x :- !) => unify x x => (of (F x) (T x) (F2 x), unify (T x) set)).

of (app M1 N1) Z (app M2 N2) :-
    of M1 TM1 M2,
    of (prod hole x\hole) _ TM2,
    unify TM1 TM2,
    TM2 = prod TY1 F,
    of N1 TY1 N2,
    subst F N2 Z.

of (atom ID) T (atom ID) :- env ID T.

of set set set.

% CSC: non dependent recursion
of (rec Rty N Base Step) Rty2 (rec Rty2 N2 Base2 Step2) :-
  of Rty set Rty2,
  of N (atom nat) N2,
  of Base Rty2 Base2,
  of Step (prod (atom nat) n\ prod Rty2 acc \ Rty2) Step2.

/************************ retype *************************/
rof T TY :- dbgpp ["retyping term ",T," : ",TY], of T TY _, !.
rof T TY :- dbgpp ["retyping failed for ",T," : ",TY,"\naborting"], $abort "1".

/* ===================== unification helpers ============================== */

subst Where What Out :- Where What = Out.

% delift M Seq Args Term DeliftedTerm [].  delifts Term w.r.t. Args for M (that
% must not occur in Term) whose canonical context is Seq
delift OC _ [] M NewM BLr :- rev BLr BL, gr-o-cp OC BL M NewM.
delift OC [T|TS] [#HD _|LS] M NewM BL :- !, % drop flexible entries
  pi a\ (of a T a :- !) => unif a a =>
    delift OC (TS a) LS M (NewM a) [drop|BL].
delift OC [T|TS] [L|LS] M NewM BL :-
  pi a\ (of a T a :- !) => unif a a =>
    delift OC (TS a) LS M (NewM a) [bind a L|BL].

% gr-o-cp M ThingsToBind Term DeliftedTerm. traverses Term and at each node
% looks if it can be grabbed or copies it.  It can be grabbed only if there
% exists an entry in ThingsToBind of the form (bind c T) where T unifies
% with Term.  If M is found, then fails (occur check)
gr-o-cp OC BL M NewM :- grab OC BL M NewM.
gr-o-cp OC BL M NewM :- copy OC BL M NewM.

:grab-pp < _: grab OC L M N :- dbgpp [grab OC L M N], false.

:grab-OCCUR-CHECK:
grab M L (#M _) _ :- !, false.

:grab-flex: % eventual restriction
grab OC L (#M L1) NewT :- !,
  sequent_of M L1 Seq [],
  % HACK: mask_sequent2 is here used to fill in L1Dl with the delifted
  % It works because it just calls the F, here (gr-o-cp OC L), on the elements
  % of the two lists.  Here L1Dl is flexible, hence it generates a list to hold
  % the delifted of L1.
  mask_sequent2 (gr-o-cp OC L) L1 L1Dl Seq MaskedSeq AllIn,
  if AllIn
    (NewT = @M L1Dl)
    (new_restricted_meta MaskedSeq NewM, assign M NewM, NewT = @M L1Dl).

:grab-here:
grab _ [bind Name A|Tl] T NewT :- unify A T, NewT = Name.
grab OC [_|Tl] T NewT :- grab OC Tl T NewT.

copy OC _ (atom A) (atom A).
copy OC _ set set.
copy OC L (app M1 M2) (app N1 N2) :-
  gr-o-cp OC L M1 N1, gr-o-cp OC L M2 N2.
copy OC L (lam S1 F1) (lam S2 F2) :- gr-o-cp OC L S1 S2,
  pi c\ unify c c => (of c S2 c :- !) => grab OC [] c c =>
    % TASSI: should the hyp be (of c S1) or (of c S2) ?
    gr-o-cp OC L (F1 c) (F2 c).
copy OC L (prod S1 F1) (prod S2 F2) :- gr-o-cp OC L S1 S2,
  pi c\ unify c c => (of c S2 c :- !) => grab OC [] c c =>
    gr-o-cp OC L (F1 c) (F2 c).
copy OC L (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  gr-o-cp OC L A1 A2, gr-o-cp OC L B1 B2,
  gr-o-cp OC L C1 C2, gr-o-cp OC L D1 D2.

% sequent_of M L1 Seq []. Fetches the metasenv entry for M, L1 is used just
% to know the length of the context. Seq is a telescope of the form
%               [T1, x1\ [T2, .. xn\ [TN, T] .. ]]
% meaning that
%                 x1 : T1, .., xn : TN |- M : T
sequent_of M [] [TY] A :- assert(M = #HD _), of (A M@) TY _.
sequent_of M [_|XS] [T|TS] A :-
  pi x\ (of x T x :- !) => sequent_of M XS (TS x) [x|A].

% mask_sequent2 F XS YS Seq MaskSeq AllIn. Returns in MaskSeq a copy of Seq
% where each item T is either prefixed by in as in "keep T", or subtituted with
% "drop".  Items filtered out are in correspondence of an X and Y (in XS and YS)
% that do not pass F.  TS has 1 more element than XS and YS (that have the same
% len). AllIn is true is Mask is made of "keep" only.
mask_sequent2 F [] [] [E] [E] true.
mask_sequent2 F [X|XS] [Y|YS] [T|TS] [E|L] B:-
  or (F X Y, E = keep T, B = Br) (E = drop, B = false),
  pi x\ mask_sequent2 F XS YS (TS x) (L x) Br.

% given the filter generates a new lambda spine that prunes "drop" items
% and returns a new meta.
new_restricted_meta FILTER M :-
  dbgpp ["building new meta restricted on ",FILTER],
  $zero_level M, $zero_level MTY, mklams FILTER M MTY, dbgpp ["obtain ", M].
  mklams [_] M MTY :- delay MTY (of MTY set MTY), delay M (of M MTY M).
  mklams [drop |L] M MTY :-
    (pi a\ pi b\ M a = M b, MTY a = MTY b), pi x\ mklams (L x) (M x) (MTY x).
  mklams [keep TY|L] M MTY :-
    pi x\ (of x TY x :- !) => unify x x => mklams (L x) (M x) (MTY x).

% Assigns a meta M and resumes all goals suspended on M
assign M NewM :- assert(M = #HD []),
  dbgpp ["<<<< assigning value ",NewM," to meta ",M],
  resume M (M = NewM),
  dbgpp ["assigned >>>> ", M].

/* =========================== unification ================================ */

unify A B :- unif ff A B.

:u-pp < _: unif A M N :- dbgpp [unif A M N], false.

:u-SAME-META: % we restrict it on the items of L1 and L2 that do not unify
unif ff (#M L1) (#M L2) :- !,
  sequent_of M L1 Seq [],
  mask_sequent2 unify L1 L2 Seq MaskedSeq AllIn,
  if AllIn true (new_restricted_meta MaskedSeq NewM, assign M NewM).

:u-ASSIGN:
unif ff (#M L) N :- !,
  sequent_of M L Seq [], delift M Seq L N NewM [], assign M NewM.
unif ff N (#M L) :- !,
  sequent_of M L Seq [], delift M Seq L N NewM [], assign M NewM.

:u-LAM-INTRO: % on the fly lambda intro
unif _ T (app (#M L1) A) :- !,
 rof A Ty,
 of (lam Ty x\ hole) _ G,
 unify (@M L1) G,
 unify T (app G A).

:u-ATOM:
unif ff set set :- !.
unif ff (atom A) (atom A) :- !.

:u-APP-APP-SAME-HD: % contextual closure + heuristic (no !, hence we may reduce)
unif ff (app H A) (app K B) :- unify H K, unify A B.
unif ff (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  unify A1 A2, unify B1 B2, unify C1 C2, unify D1 D2.

:u-SAME-RIGID: % contextual closure
unif ff (lam S F) (lam T G) :- !,
  unify S T, pi x\ (of x S x :- !) => unify x x => unify (F x) (G x).
unif ff (prod S F) (prod T G) :- !,
  unify S T, pi x\ (of x S x :- !) => unify x x => unify (F x) (G x).

:u-WHD: % BUG: redex may be deep, to fix with n-ary app; BUG: = is weak, use whd
unif _ (app (app L A) M) X :- L = lam _ x\ (lam _ y\ F x y), !, unify (F A M) X.
unif _ (app L M) X :- L = lam _ F, !, subst F M Y, unify Y X.
unif _ (atom ID) B :- body ID C, !, unify C B.
unif _ (rec _ N B R) X :- N = atom zero, !, unify B X. % BUG = is weak
unif _ (rec T N B R) X :-
  N = app (atom succ) M, !, unify (app (app R M) (rec T M B R)) X.

:u-SWAP: % we swap lhs and rhs, but only once
unif ff A B :- unif tt B A.

/* ====================== prover environment ============================== */

env zero (atom nat).
env succ (prod (atom nat) (x \ (atom nat))).
env plus (prod (atom nat) (x\ prod (atom nat) (y\ (atom nat)))).
env nat set.
env z set.
env nat_to_z (prod (atom nat) (x\ atom z)).
env vect (prod (atom nat) (x\ set)).
env vnil (app (atom vect) (atom zero)).
env vcons (prod (atom nat) (n\ prod (app (atom vect) n) (w\ app (atom vect) (app (atom succ) n)))).

body plus (lam (atom nat)
             (n\ (rec (prod (atom nat) (x\ (atom nat))) n
                   (lam (atom nat) (x\ x))
                   (lam (atom nat) m\ lam (prod (atom nat) (x\ (atom nat))) acc\
                      lam (atom nat) (n\ app (atom succ) (app acc n)))))).

/* ============================ testsuite ================================= */
% usage:
% > test _          runs all tests, only first solution of each
% > test t2         runs only test t2, only first solution of t2
% > solutions t2    generates all solutions of t2

suite TEST t1 :- % runnin of twice in a row should work
  TEST = (of (lam (atom nat) x\ hole) TY T, of T TY1 T1, TY1=TY, T1=T).
suite TEST t2 :- % typing a pi
  TEST = (of (prod (atom nat) x\ hole) TY T).
suite TEST t3 :- % meta/meta unif w pruning: ?X[] = ?Y[v]
  TEST = (of (lam (atom nat) x\ app (atom succ) hole) TY T,
          of (app (atom succ) hole) TY1 W,
          pp ["before ",T], unify (app T (atom zero)) W,
          pp ["after ",T]).
suite TEST t3bis :- % meta/meta unif w pruning: ?X[v,r] = ?Y[v,s]
  TEST = (of (lam (atom nat) x\ lam (atom nat) y\ app (atom succ) hole) _ T1,
          of (lam (atom nat) x\ lam (atom nat) y\ app (atom succ) hole) _ T2,
          pp ["before ",T1],
          pi x\ pi y\ of x (atom nat) x => of y (atom nat) y =>
          unify (app (app T1 (atom zero)) x)
                (app (app T2 (atom zero)) y),
          pp ["after ",T1]).
suite TEST t3ter :- % meta/meta unif with dependent type
  TEST = ((pi c\ unify c c => of c (atom nat) c =>
           pi d\ unify d d => of d (app (atom vect) c) d =>
            of hole (TY c d) (X c d)),
          unify (X (atom zero) (atom vnil)) (X (atom zero) (atom vnil))).
suite TEST t3quater :- % meta/meta unif with dependent type + restriction
  TEST = ((pi c\ unify c c => of c (atom nat) c =>
           pi d\ unify d d => of d (app (atom vect) c) d =>
            of hole (TY c d) (X c d)),
          pi vn \ unify vn vn => of vn (app (atom vect) atom zero) vn =>
            unify (X (atom zero) (atom vnil)) (X (atom zero) vn)).
suite TEST t4 :-
  TEST = (of hole TY1 T1, unify TY1 (atom nat), of hole TY2 T2, unify TY2 set).
% alla seconda soluzione crasha
suite TEST t5 :-
  TEST = (of (lam hole (x\ x)) (prod (atom nat) x\ atom z) X, pp ["X=",X]).
suite TEST t6 :-
  TEST = (of hole _ X, unify (app X (atom zero)) (atom zero), pp ["X=",X]).
suite TEST t7 :- % delift
  TEST = (of (lam (atom nat) x\ lam (atom nat) y\ hole) _ X,
          unify (app (app X (atom zero)) (atom zero)) (atom zero), pp ["X=",X]).
suite TEST t7-1 :- % delift occur check
  TEST = (of (lam (atom nat) x\ lam (atom nat) y\ hole) _ X,
          not (unify (app (app X (atom zero)) (atom zero)) X)).
suite TEST t7-2 :- % delift  + restriction
  TEST = (of (lam (atom nat) y\ hole) _ (lam _ X),
          of (lam (atom nat) y\ hole) _ (lam _ X1),
          of (lam (atom nat) y\ hole) _ Y,
          pi c\ unify c c => (of c (atom nat) c :- !) =>
            unify (app Y (atom zero)) (app (atom succ) (X (X1 c))),
          pp ["X=",X,"\nX1=",X1,"\nY=",Y]).

run1 N T :- pp ["INFO: running ",N], T, !, pp ["INFO: success"].
run1 N T :- pp ["ERROR: failure ",N].
test N :- suite T N, run1 N T, false.
test _ :- pp ["INFO: all tests run"].
run T :- pp ["INFO: running ",T], T.
run T :- pp ["ERROR: failure ",T].
solutions N :- suite T N, run T.


/* ============================ old stuff ================================= */

/******************** Tactics **********************/

tacsem i     (lam hole (x\ hole)).
tacsem (a M) (app M hole).
tacsem (h N) (var N).
tacsem (r M) M.

/******************** GUI **************************/

test_unify A B TA2 :-
  dbgpp ["---------> ",of A TA A1],
  of A TA A1,
  dbgpp ["---------> ",of B TB B1],
  of B TB B1,
  dbgpp ["========== ",unify TA TB],
  unify TA TB,
  dbgpp ["========== ",unify A1 B1],
  unify A1 B1.

of (var N) T M :- hyp N X, of X T M.

step_in N (decl TY F) :-
  pi x\ (of x TY x :- !) => copy x x => unify x x => hyp N x => (
  M = ss N,
  dbgpp [hyp N TY],
  step_in M (F x), !).

read_tac T :-
  $print "\ntactic> ",
  $read S,
  $parse [S,T], !.
read_tac T :- $print "\nparse error\n", read_tac T.

step_in N (goal M MTY) :-
  dbgpp ["=========\n", MTY],
  read_tac T1,
  dbgpp ["running ", T1],
  tacsem T1 P,
  dbgpp ["got term ", P],
  of P TP P1,
  dbgpp ["of type ", TP],
  unify TP MTY,
  pp ["unifies with goal!\n"],
  P1 = M, !.

step_in N G :- pp ["\ntactic error\n"], step_in N G.

step nil :- pp ["\nProof completed.\n"].
step [G|GS] :-
  step_in zz G,
  step Sig.
  
claim Claim P1 :-
  of Claim set Claim1,
  of hole THole P,
  unify THole Claim1,
  step Sig.


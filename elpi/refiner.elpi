/************************* utilities ************************/

true.
not A :- A, !, false.
not A.

is_same_flex M N :-
  $is_flex M, $is_flex N, not(dummy1__ = M, dummy2__ = N).

prt S T :- 
    $print S, $print T, $print "\n".

spy C :- prt "<<-- " C, C, prt "-->> " C.

debug :- not true.

/************************* refiner ************************/

of M TY T :- debug, prt " " (of M TY Y), not true.

of T TY W :- not($is_flex TY), !, of T TY1 W, unify TY TY1.

of hole TY T :- % this rule is bidirectional
  (pi x\ unify x x => unify x set => delay TY (of TY x TY)), 
  (pi x\ unify x x => unify x TY => delay T (of T x T)).

of (lam S F) (prod S2 T) (lam S2 F2) :-
  of S SO S2,
  unify SO set,
  (pi x\ of x S2 x => unify x x => of (F x) (T x) (F2 x)).

of (prod S F) set (prod S2 F2) :-
  of S SO S2,
  unify SO set,
  (pi x\ of x S2 x => unify x x => (of (F x) (T x) (F2 x), unify (T x) set)).

of (app M1 N1) Z (app M2 N2) :-
    of M1 TM1 M2,
    of N1 TN1 N2,
    pi x\
      of hole (_ x) (F x),
      unify TM1 (prod TN1 F),
      subst F N2 Z.

of (atom ID) T (atom ID) :- env ID T.

env zero (atom nat).
env succ (prod (atom nat) (x \ (atom nat))).
env plus (prod (atom nat) (x\ prod (atom nat) (y\ (atom nat)))).
env nat set.
env vect (prod (atom nat) (x\ set)).
env vnil (app (atom vect) (atom zero)).
env vcons (prod (atom nat) (n\ prod (app (atom vect) n) (w\ app (atom vect) (app (atom succ) n)))).

of set set set.

of (rec Rty N Base Step) Rty2 (rec Rty2 N2 Base2 Step2) :-
  of Rty TRty Rty2,
  unify TRty set,
  of N TN N2,
  unify TN (atom nat),
  of Base TBase Base2,
  unify TBase Rty2,
  of Step TStep Step2,
  unify TStep (prod (atom nat) n\ prod Rty2 acc \ Rty2).

/************************ retype *************************/
rof T TY :- of T TY _.

/************************* subst ************************/

subst Where What Out :- Where What = Out.

/************************* unify ************************/

restrict X :- pi c\ pi d\ X c = X d.

uall2 [] [] H.
uall2 [X|XS] [Y|YS] H :- unify X Y, !, pi x\ unify x x => uall2 XS YS (H x).
uall2 [X|XS] [Y|YS] H :- restrict H, pi x\ uall2 XS YS (H x).

% delift M L Y instantiates the output M s.t. @M L = Y
% CSC: BUG, we should check typability of the delifted thing
%delift0 M L Y :- prt "" (delift M L Y), not true.
delift0 M [] Y :- delift_aux M Y.
delift0 M [X|XS] Y :- pi c\ binds c X => delift0 (M c) XS Y.

delift ML M L Y :- resume ML (delift0 M L Y).

delift_aux M Y :- debug, prt "" (delift_aux M Y), not true.

% projection
delift_aux M Y :- binds V X, unify X Y, M=V.

%mimic (i.e. copy-clauses)
delift_aux M (#N L) :- !, delift_meta M N L.
delift_aux (atom A) (atom A).
delift_aux set set.
delift_aux (app M1 M2) (app N1 N2) :- delift_aux M1 N1, delift_aux M2 N2.
delift_aux M N :- delift_aux2 M N. % to avoid adding clauses before the
                                   % one for the flexible cases
delift_aux (lam S1 F1) (lam S2 F2) :-
 delift_aux S1 S2, pi c\ delift_aux2 c c => delift_aux (F1 c) (F2 c).
delift_aux (prod S1 F1) (prod S2 F2) :-
 delift_aux S1 S2, pi c\ delift_aux2 c c => delift_aux (F1 c) (F2 c).
delift_aux (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  delift_aux A1 A2, delift_aux B1 B2, delift_aux C1 C2, delift_aux D1 D2.

% delift_meta M N L holds when M L1 = @N L with L1 now implicit as binds hyps
delift_meta M N L :- prt "" (delift_meta M N L), not true.
delift_meta M N [] :- of hole TY N, M = N.
delift_meta M N [X|XS] :- delift_aux A X, ! /*red*/, delift_meta M (N A) XS.
delift_meta M N [_|XS] :- % N is restricted
 pi c\ N c = N2, delift_meta M N2 XS.

unif A M N :- debug, prt "" (unif A M N), not true.

/* M=M */
unif ff (#M L1) (#M L2) :- !, uall2 L1 L2 M.
unif ff (@M L) (#M L) :- !.
unif ff (#M L) (@M L) :- !.

/* flex=term */
unif ff T N :-
 T = #M L,
 rof N TN,
 of T TN _,
 delift T M L N.
/* term=flex */
unif ff N T :-
 T = #M L,
 of N TN,
 of T TN _,
 delift T M L N.

%unif _ (@M _) _ :- !, not true.
%unif _ _ (@M _) :- !, not true.

/* lambda-intro on the fly */
unif _ T (app H A) :-
 H = @M L1, !, rof A Ty, unif ff H (lam Ty G), unif ff T (app H A).


/* reflexive closure + heuristic for == */
/*unif ff _ T T :- !.*/
unif ff set set :- !.
unif ff (atom A) (atom A) :- !.

/* contextual closure + heuristic */
unif ff (app H A) (app K B) :- unify H K, unify A B.

/* contextual closure */
unif ff (lam S F) (lam T G) :-
  !, unify S T, pi x\ of x S x => unif ff x x => unify (F x) (G x).

unif ff (prod S F) (prod T G) :-
  !, unify S T, pi x\ of x S x => unif ff x x => unify (F x) (G x).

/* contextual closure + heuristic */
unif ff (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  unify A1 A2, unify B1 B2, unify C1 C2, unify D1 D2.

/* beta */
unif _ (app L M) X :- L = lam _ F, !, subst F M Y, unify Y X.

/* delta */
unif _ (atom ID) B :- body ID B.

/* delta */
body plus (lam (atom nat)
             (n\ (rec (prod (atom nat) (x\ (atom nat))) n
                   (lam (atom nat) (x\ x))
                   (lam (atom nat) m\ lam (prod (atom nat) (x\ (atom nat))) acc\
                      lam (atom nat) (n\ app (atom succ) (app acc n)))))) :- !.
/* iota */
unif _ (rec _ N _ _) _ :- $is_flex N, !/*red*/, fail.
unif _ (rec _ N B R) X :- N = atom zero, !, unify B X.
unif _ (rec T N B R) X :-
  N = app (atom succ) M, !, unify (app (app R M) (rec T M B R)) X.

/* symmetric */
unif ff A B :- unif tt B A.

unify A B :- unif ff A B.

/******************** Tactics **********************/

tacsem i     (lam hole (x\ hole)).
tacsem (a M) (app M hole).
tacsem (h N) (var N).
tacsem (r M) M.

/******************** GUI **************************/

test_unify A B TA2 :-
  prt "---------> " (of A TA A1),
  of A TA A1,
  prt "---------> " (of B TB B1),
  of B TB B1,
  prt "========== " (unify TA TB),
  unify TA TB,
  prt "========== " (unify A1 B1),
  unify A1 B1.

of (var N) T M :- hyp N X, of X T M.

step_in N (decl TY F) :-
  pi x\ of x TY x => copy x x => unify x x => hyp N x => (
  M = ss N,
  prt "" (hyp N TY),
  step_in M (F x), !).

read_tac T :-
  $print "\ntactic> ",
  $read S,
  $parse [S,T], !.
read_tac T :- $print "\nparse error\n", read_tac T.

step_in N (goal M MTY) :-
  prt "=========\n" MTY,
  read_tac T1,
  prt "running " T1,
  tacsem T1 P,
  prt "got term " P,
  of P TP P1,
  prt "of type " TP,
  unify TP MTY,
  $print "unifies with goal!\n\n",
  P1 = M, !.

step_in N G :- $print "\ntactic error\n", step_in N G.

step nil :- $print "\nProof completed.\n".
step [G|GS] :-
  step_in zz G,
  step Sig.
  
claim Claim P1 :-
  of Claim T Claim1,
  unify T set,
  of hole THole P,
  unify THole Claim1,
  step Sig.

/* ======================================================================== */

suite TEST :- % runnin of twice in a row
  TEST = (of (lam (atom nat) x\ hole) TY T, of T TY1 T1, TY1=TY, T1=T).
suite TEST :- % typing a pi
  TEST = (of (prod (atom nat) x\ hole) TY T).

run T :- prt "INFO: running " T, T, !, prt "INFO: success " T.
run T :- prt "ERROR: failure " T.
test :- suite T, run T, not true.
test :- $print "INFO: all tests run\n".

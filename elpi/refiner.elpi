% vim: syntax=prolog:

% enabling/disabling this will change the program hence the value of the
% counters of the tracing mechanism of elpi
debug :- true.

/************************* logic ************************/

true.
not A :- A, !, false.
not A.

/************************* utilities ************************/

% print only when debug is true and annotate with the value of the "run" counter
dbgpp S T :- debug, !, $counter ["run",N], $printl ["run:",N,": ",S,T,"\n"].
dbgpp S T.

% always print
pp S T :- $printl [S,T,"\n"].

assert P :- P, !.
assert P :- pp "assert failure " P, $abort "1".

if B T _ :- B, !, T.
if _ _ E :- E.

/************************* refiner ************************/

% this is not going to be run always, since hyp clases will have precedence
% over this rule.  Still one gets a good value for further investigation
% using: ./elpi -trace-on -trace-at run 1673 1700 -trace-only 'run' refiner.elpi
% that will print all goals processed
:ppof < _:
of M TY T :- dbgpp "" (of M TY T), false.

% bi-directional rule for lam
of (lam S F) TY (lam S2 F2) :-
  not($is_flex TY),
  TY = prod S2 T, % CSC: whd missing here!
  !,
  of S set S3,
  unify S2 S3,
  (pi x\ (of x S3 x :- !) => unify x x => of (F x) (T x) (F2 x)).

% fresh A W creates a W of level zero applied to all the local subst of A
fresh (?HD L) W :- !, $zero_level W1, mkapp W1 L W.
fresh _ _.
% ideally each rule should take care of dealing with bi-directionality
of T TY W :- not($is_flex TY), !,
%  fresh W TY1, fresh W W1,
  of T TY1 W1, coerce W1 TY1 TY W.

coerce T TyA TyE W :- dbgpp "" (coerce T TyA TyE W), false.
coerce T TyA TyE T :- unify TyA TyE.
coerce T (app (lam _ F) N) TyE W :- % CSC: whd required because we infer redexes
 subst F N TyA, coerce T TyA TyE W.
coerce T (atom nat) (atom z) (app (atom nat_to_z) T).

of hole TY T :- delay TY (of TY set TY), delay T (of T TY T).

of (lam S F) (prod S2 T) (lam S2 F2) :-
  of S set S2, (pi x\ (of x S2 x :- !) => unify x x => of (F x) (T x) (F2 x)).

of (prod S F) set (prod S2 F2) :-
  of S set S2,
  (pi x\ (of x S2 x :- !) => unify x x => (of (F x) (T x) (F2 x), unify (T x) set)).

of (app M1 N1) Z (app M2 N2) :-
    of M1 TM1 M2,
    of (prod hole x\hole) _ TM2,
    unify TM1 TM2,
    TM2 = prod TY1 F,
    of N1 TY1 N2,
    subst F N2 Z.

of (atom ID) T (atom ID) :- env ID T.

env zero (atom nat).
env succ (prod (atom nat) (x \ (atom nat))).
env plus (prod (atom nat) (x\ prod (atom nat) (y\ (atom nat)))).
env nat set.
env z set.
env nat_to_z (prod (atom nat) (x\ atom z)).
env vect (prod (atom nat) (x\ set)).
env vnil (app (atom vect) (atom zero)).
env vcons (prod (atom nat) (n\ prod (app (atom vect) n) (w\ app (atom vect) (app (atom succ) n)))).

of set set set.

% CSC: non dependent recursion
of (rec Rty N Base Step) Rty2 (rec Rty2 N2 Base2 Step2) :-
  of Rty set Rty2,
  of N (atom nat) N2,
  of Base Rty2 Base2,
  of Step (prod (atom nat) n\ prod Rty2 acc \ Rty2) Step2.

/************************ retype *************************/
rof T TY :- dbgpp "ritipo " (il termine T ":" TY), of T TY _, !.
rof T TY :- dbgpp "ritipaggio fallito! " (rof T TY), $abort "1".

/************************* subst ************************/
subst Where What Out :- Where What = Out.

/************************* unify ************************/

restrict X :- pi c\ pi d\ X c = X d.

% delift M L Y instantiates the output M s.t. @M L = Y
delift0 M L Y :- dbgpp "" (delift M L Y), false.
delift0 M [] Y :- delift_aux M Y.
delift0 M [X|XS] Y :- rof X T,
  pi c\ (of c T c :- !) => binds c X => delift0 (M c) XS Y.

binds A B :- dbgpp "" (binds A B), false.

delift ML M L Y :-
  dbgpp "<<<< assegno: " (valore Y alla meta M con subst L),
  resume ML (delift0 M L Y),
  dbgpp "assegnato >>>> " M.

delift_aux M Y :- dbgpp "" (delift_aux M Y), false.
delift_aux M NL :- NL = #N L, !,
  delift_subst L L1,
  mkhole M1 L1, mkapp M1 L1 M,
  resume NL (N = M1).
 mkhole M [] :- of hole _ M.
 mkhole M [X|XS] :- rof X TY,!, pi x\ (of x TY x :- !) => unify x x => mkhole (M x) XS.
 mkapp X [] X.
 mkapp X [Y|YS] W :-mkapp (X Y) YS W.

% projection
delift_aux M Y :- binds V X, dbgpp "trying " (grab X as V), unify X Y, M=V.

%mimic (i.e. copy-clauses)
delift_aux (atom A) (atom A).
delift_aux set set.
delift_aux (app M1 M2) (app N1 N2) :- delift_aux M1 N1, delift_aux M2 N2.
delift_aux (lam S1 F1) (lam S2 F2) :-
 delift_aux S1 S2, pi c\ unify c c => delift_aux c c =>
  (of c S1 c :- !) => delift_aux (F1 c) (F2 c).
delift_aux (prod S1 F1) (prod S2 F2) :-
 delift_aux S1 S2, pi c\ unify c c => delift_aux c c =>
  (of c S1 c :- !) => delift_aux (F1 c) (F2 c).
delift_aux (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  delift_aux A1 A2, delift_aux B1 B2, delift_aux C1 C2, delift_aux D1 D2.

% delift_subst delifts or prunes items in L
delift_subst L W :- dbgpp "" (delift_subst L W), false.
delift_subst [] [].
delift_subst [X|XS] [A|XS1] :- delift_aux A X, ! /*red*/, delift_subst XS XS1.
delift_subst [_|XS] XS1 :- delift_subst XS XS1.

rev A B :- rev-aux A B [].
rev-aux [] ACC ACC.
rev-aux [X|Y] T ACC :- rev-aux Y T [X|ACC].

unif A M N :- dbgpp "" (unif A M N), false.

:unif-SAME-META: % we restrict it on the items that do unot unify
unif ff (#M L1) (#M L2) :- !,
  sequent_of M L1 TS [],
  mask_unif L1 TS L2 Mask,
  new_restricted_meta Mask NewM,
  resume M (M = NewM).

% sequent_of M L1 Seq []. Fetches the metasenv entry for M, L1 is used just
% to know the length of the context. Seq is a telescope of the form
%               [T1, x1\ [T2, .. xn\ [TN, T] .. ]]
% meaning that
%                 x1 : T1, .., xn : TN |- M : T
sequent_of M [] [TY] A :- assert(M = #HD _), of (A M@) TY _.
sequent_of M [_|XS] [T|TS] A :- pi x\ of x T x => sequent_of M XS (TS x) [x|A].

% mask_unif XS TS YS Mask. Returns in Mask a copy of TS where each item T is
% either prefixed by in as in "in T", or subtituted with "out".  Items filtered
% out are in correspondence of and X and Y (in XS and YS) that do not unify.
% XS and YS are expected to be of the same length, and TS having 1 extra item.
mask_unif [] [E] [] [E].
mask_unif [X|XS] [T|TS] [Y|YS] [E|L] :-
  if (unify X Y) (E = in T) (E = out),
  pi x\ mask_unif XS (TS x) YS (L x).

% given the filter generates a new lambda spine that prunes "out" items
% and returns a new meta.
% CHOICE: we L a = L b, but a/b may appear but not be really used (reduction)
new_restricted_meta FILTER M :- pp "new meta that prunes " FILTER,
  $zero_level M, mklams FILTER M.
  mklams [TY] M :- delay M (of M TY M). % we reuse the type of the old meta
  mklams [in T|L] M :- pi x\ of x T x => unify x x => mklams (L x) (M x).
  mklams [out |L] M :- (pi a\ pi b\ L a = L b), (pi x\ mklams (L x) M).


/* flex=term */
unif ff T N :-
 T = #M L,
 %dbgpp " ----> ritipo " N,
 rof N TN,
 %dbgpp " ----> ritipo " T,
 rof T TT,
 unify TN TT,
 delift T M L N.
/* flex=flex already tried */
% CSC: ma da risultati diversi!
% esempio: ?1[0] = ?2 vs ?2 = ?1[0]
%unif ff (#N NL) (#T TL) :- !, false.
/* term=flex */
unif ff N T :-
 T = #M L,
 %dbgpp " ----> ritipo " N,
 rof N TN,
 %dbgpp " ----> ritipo " T,
 rof T TT,
 unify TN TT,
 delift T M L N.

%unif _ (?M _) _ :- !, false.
%unif _ _ (?M _) :- !, false.

/* lambda-intro on the fly */
unif _ T (app H A) :-
 H = #M L1, !, rof A Ty,
 of (lam Ty x\hole) _ G,
 unify H G,
 unify T (app H A).

/* reflexive closure + heuristic for == */
/*unif ff _ T T :- !.*/
unif ff set set :- !.
unif ff (atom A) (atom A) :- !.

/* contextual closure + heuristic */
unif ff (app H A) (app K B) :- unify H K, unify A B.

/* contextual closure */
unif ff (lam S F) (lam T G) :-
  !, unify S T, pi x\ (of x S x :- !) => unify x x => unify (F x) (G x).

unif ff (prod S F) (prod T G) :-
  !, unify S T, pi x\ (of x S x :- !) => unify x x => unify (F x) (G x).

/* contextual closure + heuristic */
unif ff (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  unify A1 A2, unify B1 B2, unify C1 C2, unify D1 D2.

/* beta */
% hem...
unif _ (app (app L A) M) X :- L = lam _ x\ (lam _ y\ F x y), !, unify (F A M) X.
unif _ (app L M) X :- L = lam _ F, !, subst F M Y, unify Y X.

/* delta */
unif _ (atom ID) B :- body ID B.

/* delta */
body plus (lam (atom nat)
             (n\ (rec (prod (atom nat) (x\ (atom nat))) n
                   (lam (atom nat) (x\ x))
                   (lam (atom nat) m\ lam (prod (atom nat) (x\ (atom nat))) acc\
                      lam (atom nat) (n\ app (atom succ) (app acc n)))))) :- !.
/* iota */
unif _ (rec _ N _ _) _ :- $is_flex N, !/*red*/, fail.
unif _ (rec _ N B R) X :- N = atom zero, !, unify B X.
unif _ (rec T N B R) X :-
  N = app (atom succ) M, !, unify (app (app R M) (rec T M B R)) X.

/* symmetric */
unif ff A B :- unif tt B A.

unify A B :- unif ff A B.

/******************** Tactics **********************/

tacsem i     (lam hole (x\ hole)).
tacsem (a M) (app M hole).
tacsem (h N) (var N).
tacsem (r M) M.

/******************** GUI **************************/

test_unify A B TA2 :-
  dbgpp "---------> " (of A TA A1),
  of A TA A1,
  dbgpp "---------> " (of B TB B1),
  of B TB B1,
  dbgpp "========== " (unify TA TB),
  unify TA TB,
  dbgpp "========== " (unify A1 B1),
  unify A1 B1.

of (var N) T M :- hyp N X, of X T M.

step_in N (decl TY F) :-
  pi x\ (of x TY x :- !) => copy x x => unify x x => hyp N x => (
  M = ss N,
  dbgpp "" (hyp N TY),
  step_in M (F x), !).

read_tac T :-
  $print "\ntactic> ",
  $read S,
  $parse [S,T], !.
read_tac T :- $print "\nparse error\n", read_tac T.

step_in N (goal M MTY) :-
  dbgpp "=========\n" MTY,
  read_tac T1,
  dbgpp "running " T1,
  tacsem T1 P,
  dbgpp "got term " P,
  of P TP P1,
  dbgpp "of type " TP,
  unify TP MTY,
  $print "unifies with goal!\n\n",
  P1 = M, !.

step_in N G :- $print "\ntactic error\n", step_in N G.

step nil :- $print "\nProof completed.\n".
step [G|GS] :-
  step_in zz G,
  step Sig.
  
claim Claim P1 :-
  of Claim set Claim1,
  of hole THole P,
  unify THole Claim1,
  step Sig.

/* ======================================================================== */

% usage:
% > test _          runs all tests, only first solution of each
% > test t2         runs only test t2, only first solution of t2
% > solutions t2    generates all solutions of t2

suite TEST t1 :- % runnin of twice in a row should work
  TEST = (of (lam (atom nat) x\ hole) TY T, of T TY1 T1, TY1=TY, T1=T).
suite TEST t2 :- % typing a pi
  TEST = (of (prod (atom nat) x\ hole) TY T).
suite TEST t3 :- % meta/meta unif w pruning: ?X[] = ?Y[v]
  TEST = (of (lam (atom nat) x\ app (atom succ) hole) TY T,
          of (app (atom succ) hole) TY1 W,
          pp "non-ristretto " T, unify (app T (atom zero)) W,
          pp "ristretto " T).
suite TEST t3bis :- % meta/meta unif w pruning: ?X[v,r] = ?Y[v,s]
  TEST = (of (lam (atom nat) x\ lam (atom nat) y\ app (atom succ) hole) _ T1,
          of (lam (atom nat) x\ lam (atom nat) y\ app (atom succ) hole) _ T2,
          pp "non-ristretto " T1,
          unify (app (app T1 (atom zero)) (atom zero))
                (app (app T2 (atom zero)) (app (atom succ) (atom zero))),
          pp "ristretto " T1).
suite TEST t3ter :- % meta/meta unif with dependent type
  TEST = ((pi c\ unify c c => of c (atom nat) c =>
           pi d\ unify d d => of d (app (atom vect) c) d =>
            of hole (TY c d) (X c d)),
          unify (X (atom zero) (atom vnil)) (X (atom zero) (atom vnil))).
suite TEST t4 :-
  TEST = (of hole TY1 T1, unify TY1 (atom nat), of hole TY2 T2, unify TY2 set).
% alla seconda soluzione crasha
suite TEST t5 :-
  TEST = (of (lam hole (x\ x)) (prod (atom nat) x\ atom z) X, pp "X=" X).
% non fa piu' intro on the fly
suite TEST t6 :-
  TEST = (of hole _ X, unify (app X (atom zero)) (atom zero), pp "X=" X).

run1 T :- pp "INFO: running " T, T, !, pp "INFO: success " T.
run1 T :- pp "ERROR: failure " T.
test N :- suite T N, run1 T, false.
test _ :- $print "INFO: all tests run\n".
run T :- pp "INFO: running " T, T.
run T :- pp "ERROR: failure " T.
solutions N :- suite T N, run T.

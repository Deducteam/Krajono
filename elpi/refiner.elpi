/************************* utilities ************************/

true.

is_same_flex M N :-
  $is_flex M, $is_flex N, not(dummy1__ = M, dummy2__ = N).

prt S T :- 
    $print S, $print T, $print "\n".

/************************* refiner ************************/

/* func P <=> pi i\ pi a\ pi b\ P i a => P i b => eq a b. */
/* func of                                                */
eq (of M TY1 T1) (of N TY2 T2) :- $is (pair M N).

assign_if_flex M T TY S:- $is_flex M, !, M=T, S=[goal M (ginst TY set)].
assign_if_flex M T TY [].

%of M TY T S :- prt "" (of M TY T S), not true.

of M TY T (append S S1) :- assign_if_flex M T TY S, delay M (ofr M TY T S1).

%ofr M TY T S :- prt "" (ofr M TY T S), not true.

ofr hole TY T (append S S1) :- of T TY T S, of TY set TY S1.

sigma_appl [] [] _ _ :- !.
sigma_appl [HD|Ss] [decl T S1|Ss1] X T :- HD = S1 X, sigma_appl Ss Ss1 X T.
sigma_appl (append L R) (append L1 R1) X T :- sigma_appl L L1 X T, sigma_appl R R1 X T.

ofr (lam S F) (prod S2 T) (lam S2 F2) (append Ex1 Ex3) :-
  of S SO S2 Ex1,
  unify SO set,
  pi x\ sigma Ex2\ ofr x S2 x nil => (
    of (F x) (T x) (F2 x) Ex2,
    sigma_appl Ex2 /*=*/ Ex3 x S2).

ofr (prod S F) set (prod S2 F2) (append Ex1 Ex3) :-
  of S SO S2 Ex1,
  unify SO set,
  pi x\ sigma Ex2\ ofr x S2 x nil => (
    of (F x) (T x) (F2 x) Ex2,
    unify (T x) set,
    sigma_appl Ex2 /*=*/ Ex3 x S2).

ofr (app M1 N1) Z (app M2 N2) (append (append Ex1 Ex2) Ex4) :-
    of M1 TM1 M2 Ex1,
    of N1 TN1 N2 Ex2,
    pi x\ sigma Ex3\
      of hole (_ x) (F x) Ex3,
      unify TM1 (prod TN1 F),
      sigma_appl Ex3 /*=*/ Ex4 x TN1,
      subst F N2 Z.

ofr (atom ID) T (atom ID) nil :- env ID T.

env zero (atom nat).
env succ (prod (atom nat) (x \ (atom nat))).
env plus (prod (atom nat) (x\ prod (atom nat) (y\ (atom nat)))).
env nat set.
env vect (prod (atom nat) (x\ set)).
env vnil (app (atom vect) (atom zero)).
env vcons (prod (atom nat) (n\ prod (app (atom vect) n) (w\ app (atom vect) (app (atom succ) n)))).

ofr set set set nil.

ofr (rec Rty N Base Step) Rty2 (rec Rty2 N2 Base2 Step2) (append (append Ex1 Ex2) (append Ex3 Ex4)) :-
  of Rty TRty Rty2 Ex1,
  unify TRty set,
  of N TN N2 Ex2,
  unify TN (atom nat),
  of Base TBase Base2 Ex3,
  unify TBase Rty2,
  of Step TStep Step2 Ex4,
  unify TStep (prod (atom nat) n\ prod Rty2 acc \ Rty2).

/* retype */
rof T TY :- of T TY _ _.

/************************* clean ************************/

% clean L M :- prt "" (clean L M), not true.
clean (ginst M T1) R :-
 % prt "?FLEXIBLE " M,
 $is_flex M, !,
 % prt "!FLEXIBLE " M,
 clean T1 T2,
 R = ginst M T2.
clean (ginst M1 _) M2 :- !,
 % prt "!RIGID " M1,
 clean M1 M2.
clean (app M1 N1) (app M2 N2) :- !, clean M1 M2, clean N1 N2.
clean (lam T1 F1) (lam T2 F2) :- !, clean T1 T2, pi x\ clean (F1 x) (F2 x).
clean (prod T1 F1) (prod T2 F2) :- !, clean T1 T2, pi x\ clean (F1 x) (F2 x).
clean (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  !, clean A1 A2, clean B1 B2, clean C1 C2, clean D1 D2.
clean T T :- !.

% clean_seq L M :- prt "" (clean_seq L M), not true.
clean_seq (decl S1 F1) (decl S2 F2) :- clean S1 S2, pi x\ clean_seq (F1 x) (F2 x).
clean_seq (goal V T1) (goal V T2) :- $is_flex V, !, clean T1 T2.

% clean_sigma L _ :- prt "" (clean_sigma L nil), not true.
clean_sigma [] [].
clean_sigma [X|Xs] [Y|Ys] :- clean_seq X Y, !, clean_sigma Xs Ys.
clean_sigma [_|Xs] Ys :- clean_sigma Xs Ys.
clean_sigma (append [] L1) L2 :- clean_sigma L1 L2.
clean_sigma (append [X|Xs] L1) L2 :- clean_sigma [X | append Xs L1] L2.
clean_sigma (append (append L1 L2) L3) L :- clean_sigma (append L1 (append L2 L3)) L.

/************************* subst ************************/

subst Where What Out :- Where What = Out.

/************************* unify ************************/

restrict X :- pi c\ pi d\ X c = X d.

uall2 [] [] H.
uall2 [X|XS] [Y|YS] H :- unify X Y, !, pi x\ uall2 XS YS (H x).
uall2 [X|XS] [Y|YS] H :- restrict H, pi x\ uall2 XS YS (H x).

% delift M L Y instantiates the output M s.t. @M L = Y
% CSC: BUG, we should check typability of the delifted thing
%delift M L Y :- prt "" (delift M L Y), not true.
delift M [] Y :- delift_aux M Y.
delift M [X|XS] Y :- pi c\ binds c X => delift (M c) XS Y.

%delift_aux M Y :- prt "" (delift_aux M Y), not true.

% projection
delift_aux M Y :- binds V X, unify X Y, M=V.

%mimic (i.e. copy-clauses)
delift_aux M (@N L) :- !, delift_meta M N L.
delift_aux (atom A) (atom A).
delift_aux set set.
delift_aux (app M1 M2) (app N1 N2) :- delift_aux M1 N1, delift_aux M2 N2.
delift_aux (lam S1 F1) (lam S2 F2) :-
 delift_aux S1 S2,
 pi c\ delift_aux c c =>
 delift_aux (F1 c) (F2 c).
delift_aux (prod S1 F1) (prod S2 F2) :-
 delift_aux S1 S2,
 pi c\ delift_aux c c =>
 delift_aux (F1 c) (F2 c).
delift_aux (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  delift_aux A1 A2, delift_aux B1 B2, delift_aux C1 C2, delift_aux D1 D2.

% delift_meta M N L holds when M L1 = @N L with L1 now implicit as binds hyps
%delift_meta M N L :- prt "" (delift_meta M N L), not true.
delift_meta M M [].
delift_meta M N [X|XS] :- delift_aux A X, !, delift_meta M (N A) XS.
delift_meta M N [_|XS] :-
 pi c\ N c = N2, % N is restricted
 delift_meta M N2 XS.

%unif A M N :- prt "" (unif A M N), not true.

/* M=M */
unif ff (@M L1) (@N L2) :- is_same_flex M N, !, uall2 L1 L2 M.

/* flex=term */
unif ff T N :-
 T = @M L,
 %rof T TM,
 %rof N TN,
 %unify TM TN,
 delift M L N.
/* term=flex */
unif ff N T :-
 T = @M L,
 %rof T TM,
 %rof N TN,
 %unify TN TM,
 delift M L N.

unif _ (@M _) _ :- !, not true.
unif _ _ (@M _) :- !, not true.

/* lambda-intro on the fly */
unif _ T (app H A) :-
 H = @M L1, !,
  rof A Ty,
  unif ff H (lam Ty G),
  unif ff T (app H A).


/* reflexive closure + heuristic for == */
/*unif ff _ T T :- !.*/
unif ff set set :- !.
unif ff (atom A) (atom A) :- !.

/* contextual closure + heuristic */
unif ff (app H A) (app K B) :- unify H K, unify A B.

/* contextual closure */
unif ff (lam S F) (lam T G) :-
  !,
  unify S T,
  pi x\ of x S x nil => unif ff x x =>
    unify (F x) (G x).

unif ff (prod S F) (prod T G) :-
  !,
  unify S T,
  pi x\ of x S x nil => unif ff x x =>
    unify (F x) (G x).

/* contextual closure + heuristic */
unif ff (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  unify A1 A2, unify B1 B2, unify C1 C2, unify D1 D2.

/* beta */
unif _ (app L M) X :- L = lam _ F, !, subst F M Y, unify Y X.

/* delta */
unif _ (atom ID) B :- body ID B.

/* delta */
body plus (lam (atom nat)
             (n\ (rec (prod (atom nat) (x\ (atom nat))) n
                   (lam (atom nat) (x\ x))
                   (lam (atom nat) m\ lam (prod (atom nat) (x\ (atom nat))) acc\
                      lam (atom nat) (n\ app (atom succ) (app acc n)))))) :- !.
/* iota */
unif _ (rec _ N _ _) _ :- $is_flex N, !, fail.
unif _ (rec _ N B R) X :- N = atom zero, !, unify B X.
unif _ (rec T N B R) X :- N = app (atom succ) M, !, unify (app (app R M) (rec T M B R)) X.

/* symmetric */
unif ff A B :- unif tt B A.

unify A B :- unif ff A B.

/******************** Tactics **********************/

tacsem i     (lam hole (x\ hole)).
tacsem (a M) (app M hole).
tacsem (h N) (var N).
tacsem (r M) M.

/******************** GUI **************************/

test_unify A B TA2 A2 B2 Sig :-
  prt "---------> " (of A TA A1 Ex1),
  of A TA A1 Ex1,
  prt "---------> " (of B TB B1 Ex2),
  of B TB B1 Ex2,
  prt "========== " (unify TA TB),
  unify TA TB,
  prt "========== " (unify A1 B1),
  unify A1 B1,
  $print "cleaning1\n",
  clean TA TA2,
  $print "cleaning2\n",
  clean A1 A2,
  $print "cleaning3\n",
  clean B1 B2,
  $print "cleaning4\n",
  clean_sigma (append Ex1 Ex2) Sig.

ofr (var N) T M Sig :- hyp N X, of X T M Sig.

step_in N (decl TY F) Sig2 :-
  pi x\ sigma Sig\ of x TY x nil => copy x x => unify x x => hyp N x => (
  M = ss N,
  prt "" (hyp N TY),
  step_in M (F x) Sig, !,
  sigma_appl Sig /*=*/ Sig2 x TY).

read_tac T :-
  $print "\ntactic> ",
  $read S,
  $parse [S,T], !.
read_tac T :- $print "\nparse error\n", read_tac T.

step_in N (goal M MTY) Sig :-
  prt "=========\n" MTY,
  read_tac T1,
  prt "running " T1,
  tacsem T1 P,
  prt "got term " P,
  of P TP P1 Sig,
  prt "of type " TP,
  unify TP MTY,
  $print "unifies with goal!\n\n",
  P1 = M, !.
step_in N G S :- $print "\ntactic error\n", step_in N G S.

step nil :- $print "\nProof completed.\n".
step [G|GS] :-
  step_in zz G Sig1,
  clean_sigma (append Sig1 GS) Sig2,
  step Sig2.
  
claim Claim P1 :-
  of Claim T Claim1 Sig1,
  unify T set,
  of hole THole P Sig2,
  unify THole Claim1,
  clean_sigma (append Sig1 Sig2) Sig,
  step Sig,
  clean P P1. 

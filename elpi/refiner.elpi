% vim: syntax=prolog:

/* ============================== logic =================================== */

true.
not A :- A, !, false.
not A.

/* ============================== utils =================================== */

% enabling/disabling this will change the program hence the value of the
% counters of the tracing mechanism of elpi
debug :- false.

% print only when debug is true and annotate with the value of the "run" counter
dbgpp T :- debug, !, $trace_counter ["run",N], $printl ["run:",N,": "|T].
dbgpp _.

% print with a new line at the end
pp T :- $printl T.

assert P :- P, !.
assert P :- pp ["assert failure: ",P], $abort "1".

if B T _ :- B, !, T.
if _ _ E :- E.

or A _ :- A.
or _ B :- B.

choice A _ :- A.
choice A B :- not A, B.

rev L Lr :- L dummy@ = @dummy Lr.

spy P :- pp ["----<<---- enter: ",P], P, pp ["---->>---- exit: ",P].
spy P :- pp ["---->>---- fail: ",P], false.

hide P :- ((debug :- !, false) => P).

rigid T :- not($is_flex T).

mem X [X|_] :- !.
mem X [_|XS] :- mem X XS.

list2 F [] [].
list2 F [X|XS] [Y|YS] :- F X Y, list2 F XS YS.

/* ====================== type inference helpers ========================== */

:pp-whd < _: whd I _ :- dbgpp[whd I], fail.

whd (app [HD,A|Rest]) X :- !,
  whd HD HDRed,
  if (HDRed = lam _ F)
     (subst F A Rest Reduct, whd Reduct X)
     (X = app [HDRed,A|Rest]). % fixme: app[app ]...
whd (rec T N B R) X :- !,
  whd N RedN,
  if (RedN = app [atom succ,M]) (whd (app [R,M,rec T M B R]) X)
     (if (RedN = atom zero) (X = B) (X = rec T RedN B R)).
:whd-NORED:
whd X X.

whd-progress X Y :- whd X Y, not(X = Y).
whd-w-delta X Y :-
  (whd (atom ID) RedBody :- body ID Body, whd Body RedBody) => whd X Y.
delta-betas-step (atom ID) RedBody :- body ID Body, whd Body RedBody.

/* ========================== type inference ============================== */

% dbgpp prints the value of the "run" counter that can be used to trace elpi:
%    ./elpi -trace-on -trace-at run 1673 1700 -trace-only 'run' refiner.elpi
:of-pp < _: of M TY T :- dbgpp [of M TY T], false.

:of-LAM-BIDIR:
of (lam S F) TY (lam S2 F2) :-
  rigid TY,
  whd-w-delta TY (prod S2 T),
  !,
  of S set S3,
  unify S2 S3,
  (pi x\ (of x S3 x :- !) => var _ S3 x => of (F x) (T x) (F2 x)).

% ideally each rule should take care of dealing with bi-directionality
% after this rule bidirectionaly become the trivially implemented
:of-TRIVIAL-BIDIR:
of T ExpTY NewT :- rigid ExpTY, !, of T InfTY RT, coerce RT InfTY ExpTY NewT.

:coerce-pp < _: coerce T TyA TyE W :- dbgpp [coerce T TyA TyE W], false.

coerce T (?M _) TyE T :- pp["ERROR: flexible inferred ty?\n"], $abort "1".
coerce T TyA TyE T :- unify TyA TyE, !.
coerce T TyA TyE T2 :- whd-progress TyA RedTyA, !, coerce T RedTyA TyE T2.
coerce T TyA TyE T2 :- whd-progress TyE RedTyE, !, coerce T TyA RedTyE T2.
:coerce-DELTA:
coerce T TyA TyE T2 :- delta-betas-step TyA RedTyA, !, coerce T RedTyA TyE T2.
coerce T TyA TyE T2 :- delta-betas-step TyE RedTyE, !, coerce T TyA RedTyE T2.

of hole TY T :- delay TY (waiting-for TY set), delay T (waiting-for T TY).

:waiting-for-pp < _: waiting-for T TY :- dbgpp[waiting-for T TY], false.
waiting-for (?T L) TY :- get-canonical M, !, of (@M L) TY (@T L).
waiting-for (?T L) TY :- get-local M, !, of M TY (@T L).

of (#F L) TY T :- T = @F L, waiting-for (@F L) TY.

of (lam S F) (prod S2 T) (lam S2 F2) :-
  of S set S2, pi x\ (of x S2 x :- !) => var _ S2 x => of (F x) (T x) (F2 x).

of (prod S F) set (prod S2 F2) :-
  of S set S2, pi x\ (of x S2 x :- !) => of (F x) set (F2 x).

of (app [T|U]) TyV V :- of T TyT T1, eat-prod T1 [] [] TyT U V TyV.

:eat-prod-pp < _: eat-prod T XS XSTY TY A _ _ :- dbgpp [eat-prod T XS XSTY TY A], false.

% eat-prod HD Processed TyHD Args Res ResTy, eats one by one Args, moves them
% to Processed..
mk-hole-ctx TYS T TY :- dbgpp[mk-hole-ctx TYS T TY], false.
mk-hole-ctx [] T TY :- of hole TY T.
mk-hole-ctx [UTY|USTY] T TY :-
  pi x\ (of x UTY x :- !) => mk-hole-ctx USTY (T x) (TY x).

fresh-prod US USTY OldM :-
  $zero_level NewTgt, $zero_level NewTgtTy,
  rev USTY RUSTY,
  mk-hole-ctx RUSTY NewTgt NewTgtTy,
  %pp[ mk-hole-ctx RUSTY NewTgt NewTgtTy ],
  [_|TlUS] = US,
  [UTY|_] = USTY,
  pp[unify OldM (prod UTY x\ ([x|TlUS] NewTgt@))],
  unify OldM (prod UTY x\ ([x|TlUS] NewTgt@)),
  pp["---> ",OldM]
.

eat-prod T XS _ TY []     (app [T| Args]) TY :- rev XS Args.
eat-prod T XS XSTY TY [dots|US] V TyV :-
  whd-w-delta TY WhdTY,
  if (WhdTY = prod Src Tgt)
   % it is not greedy, it tries them all
   (or
     (eat-prod T XS XSTY TY US V TyV)
     (eat-prod T XS XSTY TY [hole,dots|US] V TyV))
   % at the moment it is like in Matita: no saturation if flexible arity
   (eat-prod T XS XSTY TY US V TyV).
eat-prod T XS XSTY TY [U|US] V TyV :-
  whd-w-delta TY WhdTY,
  if (WhdTY = prod Src Tgt)
    (of U Src U1,
     eat-prod T [U1|XS] [Src|XSTY] (Tgt U1) US V TyV)
    (WhdTY = #M _,
     of U TyU U1,
     %of (prod TyU x\ mkapp hole XS) _ Prod, Prod = prod _ Tgt,
     fresh-prod [U1|XS] [TyU|XSTY] WhdTY,
     %pp[fresh-prod [U1|XS] [TyU|XSTY] WhdTY],
     WhdTY = prod _ Tgt,
     eat-prod T [U1|XS] [TyU|XSTY] (Tgt U1) US V TyV).
% ,
% pp["E-P ?= ", unify WhdTY Prod],
%      debug => unify WhdTY Prod,
% pp["E-P  = ", unify WhdTY Prod]
% ).

% CSC: non dependent recursion
of (rec Rty N Base Step) Rty2 (rec Rty2 N2 Base2 Step2) :-
  of Rty set Rty2,
  of N (atom nat) N2,
  of Base Rty2 Base2,
  of Step (prod (atom nat) n\ prod Rty2 acc \ Rty2) Step2.

of set set set.
of (atom ID) T (atom ID) :- env ID T.


rof T TY :- dbgpp ["retyping term ",T," : ",TY], of T TY _, !.
rof T TY :- dbgpp ["retyping failed for ",T," : ",TY,"\naborting"], $abort "1".

/* ===================== unification helpers ============================== */

subst Where What Rest Out :- % fixme: app[app]...
  if (Rest = []) (Out = Where What) (Out = app [Where What|Rest]).

% delift M Seq Args Term DeliftedTerm [].  delifts Term w.r.t. Args for M (that
% must not occur in Term) whose canonical context is Seq
:delift < _: delift M S A T D L :- dbgpp[delift M S A T D L], false.
delift OC _ [] M NewM BLr :- rev BLr BL, gr-o-cp OC BL M NewM.
delift OC [T|TS] [#HD _|LS] M NewM BL :- !, % drop flexible entries
  pi a\ (of a T a :- !) =>
    delift OC (TS a) LS M (NewM a) [drop|BL].
delift OC [T|TS] [L|LS] M NewM BL :-
  pi a\ (of a T a :- !) =>
    delift OC (TS a) LS M (NewM a) [bind a L|BL].

% gr-o-cp M ThingsToBind Term DeliftedTerm. traverses Term and at each node
% looks if it can be grabbed or copies it.  It can be grabbed only if there
% exists an entry in ThingsToBind of the form (bind c T) where T unifies
% with Term.  If M is found, then fails (occur check)
gr-o-cp OC BL M NewM :- or (grab OC BL M NewM) (copy OC BL M NewM).

:grab-pp < _: grab OC L M _ :- dbgpp [grab OC L M], false.

:grab-OCCUR-CHECK:
grab M L (#M _) _ :- !, false.

:grab-flex: % eventual restriction
grab OC L (#M L1) NewT :- !,
  sequent_of M L1 Seq [],
  % HACK: mask_sequent2 is here used to fill in L1Dl with the delifted
  % It works because it just calls the F, here (gr-o-cp OC L), on the elements
  % of the two lists.  Here L1Dl is flexible, hence it generates a list to hold
  % the delifted of L1.
  mask_sequent2 (gr-o-cp OC L) L1 L1Dl Seq MaskedSeq AllIn,
  if AllIn
    (NewT = @M L1Dl)
    (new_restricted_meta MaskedSeq NewM, assign M NewM, NewT = @M L1Dl).

:grab-here:
grab _ [bind Name A|Tl] T NewT :- unify A T, NewT = Name.
grab OC [_|Tl] T NewT :- grab OC Tl T NewT.

:copy-pp < _: copy OC L M _ :- dbgpp [copy OC L M], false.

copy OC _ (atom A) (atom A).
copy OC _ set set.
copy OC L (app MS) (app NS) :- list2 (gr-o-cp OC L) MS NS.
copy OC L (lam S1 F1) (lam S2 F2) :- gr-o-cp OC L S1 S2,
  pi c\ unify c c => (of c S2 c :- !) => grab OC [] c c =>
    % TASSI: should the hyp be (of c S1) or (of c S2) ?
    gr-o-cp OC L (F1 c) (F2 c).
copy OC L (prod S1 F1) (prod S2 F2) :- gr-o-cp OC L S1 S2,
  pi c\ unify c c => (of c S2 c :- !) => grab OC [] c c =>
    gr-o-cp OC L (F1 c) (F2 c).
copy OC L (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  gr-o-cp OC L A1 A2, gr-o-cp OC L B1 B2,
  gr-o-cp OC L C1 C2, gr-o-cp OC L D1 D2.

% sequent_of M L1 Seq []. Fetches the metasenv entry for M, L1 is used just
% to know the length of the context. Seq is a telescope of the form
%               [T1, x1\ [T2, .. xn\ [TN, T] .. ]]
% meaning that
%                 x1 : T1, .., xn : TN |- M : T
sequent_of M [] [TY] A :- assert(M = #HD _), waiting-for (A M@) TY, !.
sequent_of M [] [_] _ :- pp["ERROR: unable to get sequent of ",M], $abort "1".
sequent_of M [_|XS] [T|TS] A :-
  pi x\ (of x T x :- !) => sequent_of M XS (TS x) [x|A].

% mask_sequent2 F XS YS Seq MaskSeq AllIn. Returns in MaskSeq a copy of Seq
% where each item T is either prefixed by in as in "keep T", or subtituted with
% "drop".  Items filtered out are in correspondence of an X and Y (in XS and YS)
% that do not pass F.  TS has 1 more element than XS and YS (that have the same
% len). AllIn is true is Mask is made of "keep" only.
mask_sequent2 F [] [] [E] [E] true.
mask_sequent2 F [X|XS] [Y|YS] [T|TS] [E|L] B:- % we could use or here
  choice (F X Y, E = keep T, B = Br) (E = drop, B = false),
  pi x\ mask_sequent2 F XS YS (TS x) (L x) Br.

% given the filter generates a new lambda spine that prunes "drop" items
% and returns a new meta.
new_restricted_meta FILTER M :-
  dbgpp ["building new meta restricted on ",FILTER],
  $zero_level M, $zero_level MTY, mklams FILTER M MTY, dbgpp ["obtain ", M].
  mklams [_] M MTY :- delay MTY (waiting-for MTY set), delay M (waiting-for M MTY).
  mklams [drop|L] M MTY :-
    (pi a\ pi b\ M a = M b, MTY a = MTY b), pi x\ mklams (L x) (M x) (MTY x).
  mklams [keep TY|L] M MTY :-
    if (of TY _ _)
      (pi x\ (of x TY x :- !) => mklams (L x) (M x) (MTY x))
      (mklams [drop|L] M MTY).

% Assigns a meta M and resumes all goals suspended on M
assign M NewM :- assert(M = #HD []), % resume adds the explicit subst
  pp ["<<<< assigning value ",NewM," to meta ",M],
  resume M (get-canonical NewM),
  pp ["assigned >>>> ", M].
assign-local M NewM :- assert(M = #HD []), % resume adds the explicit subst
  dbgpp ["<<<< assigning the delifted of value ",NewM," to meta ",M],
  resume M (get-local NewM),
  dbgpp ["assigned >>>> ", M].

/* =========================== unification ================================ */

unify A B :- unif ff A B.

:u-pp < _: unif A M N :- dbgpp [unif A M N], false.

:u-EQ: unif ff X X :- !.

:u-SAME-META: % we restrict it on the items of L1 and L2 that do not unify
unif ff (#M L1) (#M L2) :- !,
  sequent_of M L1 Seq [],
  mask_sequent2 unify L1 L2 Seq MaskedSeq AllIn,
  if AllIn true (new_restricted_meta MaskedSeq NewM, assign M NewM).

:u-ASSIGN:
unif ff (#M L) N :- !,
  sequent_of M L Seq [], delift M Seq L N NewM [], assign M NewM.
unif ff N (#M L) :- !,
  sequent_of M L Seq [], delift M Seq L N NewM [], assign M NewM.

:u-LAM-INTRO: % on the fly lambda intro
unif ff T (app [#M L1,A|Rest]) :- !,
 rof A Ty, of (lam Ty x\ hole) _ G, unify (@M L1) G, unify T (app [G,A|Rest]).
unif ff (app [#M L1,A|Rest]) T :- !,
 rof A Ty, of (lam Ty x\ hole) _ G, unify (@M L1) G, unify (app [G,A|Rest]) T.

:u-APP-APP-SAME-HD: % contextual closure + heuristic (no !, hence we may reduce)
unif ff (app AS) (app BS) :- list2 unify AS BS.
unif ff (rec A1 B1 C1 D1) (rec A2 B2 C2 D2) :-
  unify A1 A2, unify B1 B2, unify C1 C2, unify D1 D2.

:u-SAME-RIGID: % contextual closure
unif ff (lam S F) (lam T G) :- !,
  unify S T, pi x\ (of x S x :- !) => unify (F x) (G x).
unif ff (prod S F) (prod T G) :- !,
  unify S T, pi x\ (of x S x :- !) => unify (F x) (G x).

:u-WHD:
unif _ X Y :- whd-progress X Z, !, unify Z Y.

:u-SWAP: % we swap lhs and rhs, but only once
unif ff A B :- unif tt B A.

/* ====================== prover environment ============================== */

env zero (atom nat).
env succ (prod (atom nat) (x \ (atom nat))).
env plus (prod (atom nat) (x\ prod (atom nat) (y\ (atom nat)))).
env nat set.
env z set.
env nat_to_z (prod (atom nat) (x\ atom z)).
env vect (prod (atom nat) (x\ set)).
env vnil (app [atom vect,atom zero]).
env vcons (prod (atom nat) (n\ prod (app [atom vect,n]) (w\ app [atom vect,app [atom succ,n]]))).

body plus (lam (atom nat)
             (n\ (rec (prod (atom nat) (x\ (atom nat))) n
                   (lam (atom nat) (x\ x))
                   (lam (atom nat) m\ lam (prod (atom nat) (x\ (atom nat))) acc\
                      lam (atom nat) (n\ app [atom succ, app [acc,n]]))))).

:coerce-NZ < coerce-DELTA:
coerce T (atom nat) (atom z) (app [atom nat_to_z, T]).

/* ============================ testsuite ================================= */
% usage:
% > test            runs all tests
% > solutions t2    generates all solutions of t2

suite TEST t1 "1" :- % runnin of twice in a row should work
  TEST = (of (lam (atom nat) x\ hole) TY T, of T TY1 T1, TY1=TY, T1=T).
suite TEST t2 "1" :- % typing a pi
  TEST = (of (prod (atom nat) x\ hole) TY T).
suite TEST t3 "1" :- % meta/meta unif w pruning: ?X[] = ?Y[v]
  TEST = (of (lam (atom nat) x\ app [atom succ, hole]) TY T,
          of (app [atom succ, hole]) TY1 W,
          dbgpp["before ",T],expect [(T=lam _ (x\app [_,#F1 (A1 x)]),A1=x\[x])],
          unify (app [T,atom zero]) W,
          dbgpp["after  ",T],expect [(T=lam _ (x\app [_,#F2 (A2 x)]),A2=x\[])]).
suite TEST t3-2 "2" :- % meta/meta unif w pruning: ?X[v,r] = ?Y[v,s]
  TEST = (of (lam (atom nat) x\ lam (atom nat) y\ app [atom succ, hole]) _ T1,
          of (lam (atom nat) x\ lam (atom nat) y\ app [atom succ, hole]) _ T2,
          %pp ["before ",T1], pp ["before ",T2],
          expect [(T1=lam _ x\lam _ y\app [_,#F1 (A1 x y)],A1=x\y\[y,x])],
          pi x\ pi y\ of x (atom nat) x => of y (atom nat) y =>
          unify (app [T1, atom zero, x]) (app [T2, atom zero, y]),
          %pp ["after  ",T1], pp ["after  ",T2],
          expect [(T1=lam _ x\lam _ y\app [_, #F2 (A2 x y)],A2=x\y\[x]),
                  (T1=lam _ x\lam _ y\app [_, #F2 (A2 x y)],A2=x\y\[atom zero])]).
suite TEST t3-3 "1" :- % meta/meta unif with dependent type
  TEST = ((pi c\ unify c c => of c (atom nat) c =>
           pi d\ unify d d => of d (app [atom vect, c]) d =>
            of hole (TY c d) (X c d)),
          unify (X (atom zero) (atom vnil)) (X (atom zero) (atom vnil)),
          dbgpp ["X=",X],
          expect [%(X = x\y\#F (L x y),L=x\y\[]),
                  (X = x\y\#F (L x y),L=x\y\[x,y])%,
                  %(X = x\y\#F (L x y),L=x\y\[y]),
                  %(X = x\y\#F (L x y),L=x\y\[x])]
]).
suite TEST t3-4 "1" :- % meta/meta unif with dependent type + restriction
  TEST = ((pi c\ of c (atom nat) c =>
           pi d\ of d (app [atom vect, c]) d =>
            of hole (TY c d) (X c d)),
          (pi vn \ of vn (app [atom vect, atom zero]) vn =>
            unify (X (atom zero) (atom vnil)) (X (atom zero) vn)),
          pp["after= ",X],
          expect [%(X=x\y\#F (L x y),L=x\y\[]),
                  (X=x\y\#F (L x y),L=x\y\[x])]).
suite TEST t4 "1" :-
  TEST = (of hole TY1 T1, unify TY1 (atom nat), of hole TY2 T2, unify TY2 set).
suite TEST t5 "1" :-
  TEST = (of (lam hole (x\ x)) (prod (atom nat) x\ atom z) X,
          dbgpp ["X=",X], expect [X=lam _ x\ app [atom nat_to_z, x]]).
suite TEST t6 "2" :-
  TEST = (of hole _ X, unify (app [X, atom zero]) (atom zero),
          pp ["X=",X], expect [(X=lam _ x\ x), (X=lam _ x\ (atom zero))]).
suite TEST t7 "3" :- % delift
  TEST = (of (lam (atom nat) x\ lam (atom nat) y\ hole) _ X,
          unify (app [X, atom zero,atom zero]) (atom zero),
          dbgpp ["X=",X],expect [(X=lam _ x\lam _ y\ x), (X=lam _ x\lam _ y\ y),
                               (X=lam _ x\lam _ y\ atom zero)]).
suite TEST t7-2 "1" :- % delift occur check
  TEST = (of (lam (atom nat) x\ lam (atom nat) y\ hole) _ X,
          not (unify (app [X, atom zero, atom zero]) X)).
suite TEST t7-3 "1" :- % delift  + restriction
  TEST = (of (lam (atom nat) y\ hole) _ (lam _ X),
          of (lam (atom nat) y\ hole) _ (lam _ X1),
          of (lam (atom nat) y\ hole) _ Y,
          pi c\ unify c c => (of c (atom nat) c :- !) =>
            unify (app [Y, atom zero]) (app [atom succ, X (X1 c)]),
          dbgpp ["X=",X,"\nX1=",X1,"\nY=",Y],
          expect [(X = w\ #F1 (A1 w), A1=w\[w], X1 = w\ #F2 (A2 w), A2=w\[])%,
                  %(X = w\ #F1 (A1 w), A1=w\[],  X1 = w\ #F2 (A2 w), A2=w\[w])
]).
suite TEST t8 "1" :- % whd
  TEST = (SUCC = atom succ, ZERO = atom zero, NAT = atom nat,
          N2 = app [SUCC,app[SUCC,ZERO]],
          MkPi = lam NAT n\rec set n NAT (lam NAT m\lam set ty\ prod NAT w\ ty),
          (pi f\ of f (app [MkPi,N2]) f => of (app [f,ZERO,ZERO]) NAT (Y f))).
% suite TEST t8-1 "1" :- % flex head, BROKEN bubble-up, too many hvs
%   TEST = (NAT = atom nat,
%           (pi c1\ pi c2\ pi c3\ pi t1\ pi t2\
%             of t1 (prod NAT x\set) t1 =>
%             of t2 (prod NAT x\ prod (app [t1,x]) y\set) t2 =>
%             of c1 NAT c1 =>
%             of c2 (app [t1,c1]) c2 => of c3 (app [t2,c1,c2]) c3 =>
%             unify c1 c1 => unif1 c2 c2 => unify c3 c3 =>
%             unify t1 t1 => unify t2 t2 =>
%             copy c1 c1 => unif1 c2 c2 => copy c3 c3 =>
%             copy t1 t1 => copy t2 t2 =>
%             sigma T\sigma TY\
%               of (lam hole f\ app [f,c1,c2,c3]) TY T,
%               pp["T=",T])).
suite TEST t8-2 "4" :- % flex head (esempio e-prod paper CSC + TASSI + ...)
  TEST = (NAT = atom nat, T1 = atom t1, T2 = atom t2, 
          C1 = atom c1, C2 = atom c2, C3 = atom c3,
          (%pi c1\ pi c2\ pi c3\ pi t1\ pi T2\
            (of T1 (prod NAT x\set) T1 :- !) =>
            (of T2 (prod NAT x\ prod (app [T1,x]) y\set) T2 :- !) =>
            (of C1 NAT C1 :- !) =>
            (of C2 (app [T1,C1]) C2 :- !) =>
            (of C3 (app [T2,C1,C2]) C3 :- !) =>
            %sigma T\sigma TY\
              of (lam hole f\ app [atom succ,app [f,C1,C2,C3]]) TY T,
              pp["T=",T])).

run T :- pp ["INFO: running ",T], T.
run T :- pp ["ERROR: failure ",T].
solutions N :- suite T N _, run T.

test :- all-suite [] L, !, all-t L, !, report-t L FAIL,
        if (FAIL=[]) (pp["\nINFO: All tests passed\n"], $exit "0")
                     (pp["\nERROR: Some tests failed: "|FAIL],$exit "1").
all-suite L [run1 N T _ B _|L1] :-
  suite T N B, not(mem N L), !, all-suite [N|L] L1.
all-suite _ [].
all-t [].
all-t [X|XS] :- X, $incr "sols", fail.
all-t [run1 _ _ N _ U|XS] :-
  $get["sols",N], $reset "sols",
  $get["unexp",U], $reset "unexp",
  all-t XS.
run1 N T _ _ _ :-
  pp["INFO: running ",N], T, $get["sols",S], pp["INFO:   success #",S].
run1 N T _ _ _ :- $get["sols","0"], !, pp ["ERROR:   failure ",N], fail.
report-t [] ["\n"].
report-t [run1 N _ "0" _ _|XS] E :- !,
  E = ["\n ",N,"\tNo solution"|ACC], report-t XS ACC.
report-t [run1 N _ X X "0"|XS] ACC :- !, report-t XS ACC.
report-t [run1 N _ X Y "0"|XS] E :- !,
  E = ["\n ",N,"\tWrong number of solutions (",X, " instead of ",Y,")"|ACC],
  report-t XS ACC.
report-t [run1 N _ _ _ _|XS] E :- !,
  E = ["\n ",N,"\tUnexpected solution"|ACC], report-t XS ACC.
expect [X|XS] :- if X true (expect XS).
expect [] :- $get["sols",S],pp["ERROR: Unexpected sol #",S],$incr "unexp",false.

/* ============================== UI ==================================== */

/* ========= Tactics ======== */
tacsem i M :- assign-local M (lam hole (x\ hole)).  /* # */
tacsem (n S) M :- var S _ _.                        /* assign name */
tacsem (a T) M :- assign-local M (app [T, dots]).   /* @ */
tacsem h M :- var _ _ Id, assign-local M Id.        /* assumption */
%tacsem (r T) M :- assign-local M T.                 /* refine */

of (hyp Name) T X :- var Name T X, !.
:whd-VAR < whd-NORED: whd (hyp Name) Id :- var Name _ Id, !.

read_tac T :- $print "\ntactic> ", $read S, $parse [S,T], pp[T], !.
read_tac T :- $print "\nparse error\n", read_tac T.

exec_tac u _ :- !, false.                           /* undo */
exec_tac T M :- tacsem T M, loop.
exec_tac T M :- pp ["Tactic failed!"], loop.

step M :- read_tac T, exec_tac T M. 
loop :- $schedule [(sigma M\ M, step M), pp["\nProof completed.\n"]].

claim Claim P :-
  of Claim set Claim1, !,
  of hole Claim1 P,
  loop.


% vim: set ft=lprolog:

macro @app :- elpi_app.
macro @lam :- elpi_lam.
macro @cdata :- elpi_cdata.


if B T _ :- B, !, T.
if _ _ E :- E.

infix `: 141.
type $$?? A.

spy P :- $print "----<<---- enter: " P, P, $print "---->>---- exit: " P, !.
spy P :- $print "---->>---- fail: " P, fail.

% --------- error reporting 
assert P _ :- P, !.
assert _ (type-err T Ty ETy) :- !, checking LOC,
  $print LOC "Type error:" {pp T} "has type" Ty "but is used with type" ETy.
assert _ (wrong-arity T Ty A) :- !, checking LOC,
  $print LOC "Type error:" {pp T} "has type" Ty "but is applied to" {pp-list A}.

mode (pp i o).
type pp A -> B -> prop.
pp (@app [HD|L]) T :- !,
  if (pp HD PHD, not (HD = PHD))
    (pp-list L PL, mk-app [c PHD|PL] T)
    (pp-list [HD|L] PL, mk-app PL T).
pp (@lam F) T :- !, pi x\ pp (F x) (T x).
pp X X :- !.
pp _ unprintable. % pp should never fail

mode (pp-list i o).
pp-list [X|XS] [Y|L] :- pp-list XS L, pp X Y.
pp-list [] [].

mode (mk-app i o).
unsafe-cast X X.
type unsafe-cast A -> B -> prop.
mk-app [X] X.
mk-app [X, A|XS] T :- unsafe-cast X X', mk-app [X' A | XS] T.

% --------- typing of terms
mode (refresh-poly-ty i o).
refresh-poly-ty (pi F) T :- !, refresh-poly-ty (F _FRESH) T.
refresh-poly-ty X X.

mode (of i o i). % BUG: matching generates chains?

of (-> A B) _ E :- of A _ E, of B _ E.

of (@cdata CData) Ty _ :-
  $is_cdata CData CTy, !, assert (Ty = CTy) (type-err CData CTy Ty).

of (@app [HD|ARGS]) TY E :- !,
  of HD HDTY E, of-app HDTY ARGS TY HD (Done - Done) E.
of (@lam F) Ty E :- !,
  Ty = -> _A B,
( (pi E\ of x T E),
   (pi E A Tx\ of (x A) Tx E :- of A TA E, T = -> TA Tx),
   (pi E A B Tx\ of (x A B) Tx E :- of A TA E, of B TB E, T = -> TA (-> TB Tx)))
 => of (F x) B E.

of (pi F) Ty E :- !, Ty = prop, pi x\
 ( (pi E\ of x T E),
   (pi E A Tx\ of (x A) Tx E :- of A TA E, T = -> TA Tx),
   (pi E A B Tx\ of (x A B) Tx E :- of A TA E, of B TB E, T = -> TA (-> TB Tx)))
 => of (F x) prop E.
of (sigma F) Ty E :- !, Ty = prop, pi x\
   (pi E\ of x _FRESH E)
 => of (F x) prop E.

of Id ETy (node Id PTy _ _) :- !,
  refresh-poly-ty PTy Ty, assert (Ty = ETy) (type-err Id Ty ETy).
of Id Ty (node Id1 _ L R) :- !, if ($lt Id Id1) (of Id Ty L) (of Id Ty R).
of Id Ty (?? as TL) :- assert (TL = (node Id  Ty _FRESH1 _FRESH2)) (type-err Id Ty wtf).

of Id Ty _ :- of Id ETy _, assert false (type-err Id Ty ETy).

of-app (-> T TS) [X|XS] TGT HD (B - BT) E :- !,
  of X T E, BT = X :: TL, of-app TS XS TGT HD (B - TL) E.
of-app Ty [] TGT HD (D - []) _ :- !,
  assert (TGT = Ty) (type-err (@app [HD|D]) Ty TGT).
of-app Ty Args _ HD (D - []) _ :- !,
  assert false (wrong-arity (@app [HD|D]) Ty Args).

% --------- typing of clauses
%  we get names for Args

typecheck [] _.
typecheck [($$, Loc Names Clause)|Rest] E :-
  % $print {$counter "run"} "type checking " Loc,
  checking Loc => of-clause Names Clause E, !,
  typecheck Rest E.

of-clause [N|NS] (pi C) E :- !, pi x\ 
 ( (pp x N :- !),
   (pi E Tf\ of x Tf E :- !, assert (T = Tf) (type-err x T Tf)),
   (pi E A Tx TA\ of (x A) Tx E :- !, of A TA E, assert (T = -> TA Tx) (type-err x T (-> TA Tx))),
   (pi E A B Tx\ of (x A B) Tx E :- !, of A TA E, of B TB E, /*FIXME*/T = -> TA (-> TB Tx)))
  => of-clause NS (C x) E.
of-clause _ C E :- of C prop E.

l2t [] _.
l2t [Id `: Ty | L] E :-
  if (of Id Ty E) (l2t L E)
     ($print "duplicate type declaration for" Id, l2t L E).

typecheck-program P EL :-
  l2t EL E,
  $gettimeofday Begin,
  typecheck P E,
  $gettimeofday Mid,
  Time is Mid - Begin,
  $print "End type checking" Time,
  warn-linear P,
  WTime is {$gettimeofday} - Mid,
  $print "End warning" WTime,
  true.
  % $print "given:" E,
  % $print "inferred:" FRESH.

type of X -> Y -> list Z -> prop.
type $$-> X -> X -> prop.
type wrong-arity A -> B -> list A -> err.

main :- foo X, foo X Y.

% ---------- warnings

mode (report i).
report [].
report [V `: 1 + ?? |NS] :- !,
  pp V VN,
  if (not($rex_match "^_" VN))
    (checking LOC,
     MSG is "Warning: " ^ VN ^ " is linear, name it _" ^ VN ^ " please",
     $print LOC MSG)
    true,
  report NS.
report [V `: ?? |NS] :-
  checking LOC, $print LOC {pp V} "is unused", report NS.
report [_ `: _ | NS] :- report NS.

type count A -> list B -> prop.
count (pi F) E :- pi x\
 ( (pi E A\ count (x A) E :- !, count x E, count A E),
   (pi E A B\ count (x A B) E :- !, count x E, count A E, count B E)
 ) => count (F x) E.
count (sigma F) E :- pi x\
 ( (pi E A\ count (x A) E :- !, count x E, count A E),
   (pi E A B\ count (x A B) E :- !, count x E, count A E, count B E)
 ) => count (F x) E.
count (@lam F) E :- pi x\
 ( (pi E A\ count (x A) E :- !, count x E, count A E),
   (pi E A B\ count (x A B) E :- !, count x E, count A E, count B E)
 ) => count (F x) E.
count (@app [X|XS]) E :- !, count X E, count (@app XS) E.
count (@app []) _ :- !.
count (-> A B) E :- !, count A E, count B E.
count X E :- var X, !, incr X E.
count _ _.

mode (incr i i).
incr X [X `: K | _] :- add1 K.
incr X [_ | XS] :- incr X XS.

mode (add1 i).
add1 (?? as K) :- K = 1 + _FRESH.
add1 (1 + K) :- add1 K.

check-non-linear [N|NS] (pi C) L :- pi x\
  ( (pp x N :- !),
    (var x),
    (pi E A\ count (x A) E :- !, count x E, count A E),
    (pi E A B\ count (x A B) E :- !, count x E, count A E, count B E)
 ) => check-non-linear NS (C x) [x `: _FRESH | L].
check-non-linear _ C L :-
  count C L, report L.

warn-linear [].
warn-linear [($$, Loc Names Clause)|CS] :-
  checking Loc =>  check-non-linear Names Clause [],
  warn-linear CS.


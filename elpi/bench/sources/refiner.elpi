canon_of X T Z :- not (is_flex Z), !, of Z T X.
canon_of X T Z :- is_flex X, !, $delay (canon_of X T Z) [X,Z].
canon_of X T Z :- of X T X.

of X Y X :- is_flex X, !, $delay (of X Y X) X.
of X Y X' :- of_ X Y X'.

of_ implicit T X :- $delay (canon_of X T Z) [X,Z].

of_ (app F A) (T A) (app F' A') :- of A TA A', of F TF F', TF = prod TA T.
of_ (lam F) (prod A T) (lam F') :- pi x\ of_ x A x => of (F x) (T x) (F' x).

of_ vnil (vect 0) vnil.
of_ (vcons N V) (vect (N + 1)) (vcons N V') :- of V TV V', TV = vect N.

of_ 0 nat 0.
of_ 1 nat 1.
of_ (A + B) nat (A' + B') :- of A nat A', of B nat B'.

% Type checking
%main :-
% of (app (app (lam n\lam v\ vcons n v) (0 + 1)) (vcons 0 vnil)) T,
% $print T.

% Refinement
% main :-
%  of (app (app X (0 + 1)) (vcons 0 vnil)) T,
%  $print X T,
%  $print_delayed,
%  $print "--------------",
%  X = (lam n\lam v\ vcons n v),
%  $print T.

main :-
   of (lam a\lam b\ implicit) (prod nat x\ prod (vect x) v\ nat) (lam a\lam b\ X a b),
   of (X (0 + 1) (vcons 0 vnil)) Ti R,
   of (X 0 vnil) Ti R',
   % $print X Ti "->" R R',
   % X = a\b\a.
   $delay (assign X (a\b\ a + implicit)) A,
   $print "AAA" (of (X (0 + 1) (vcons 0 vnil)) Ti R),
   $print "BBB" (of (X 0 vnil) Ti R').

propagate [ (G1 ?- canon_of (X @ Cl) TY _) ]
          [ (G2 ?-       of (X @ Ll) Y  R) ]
          (GOAL, T_ARGS = Y) :-
  $closed T, app T Cl TY, app T Ll T_ARGS, compat Cl [] G1 Ll COMPAT [],
  imply G2 COMPAT GOAL.

propagate [ (_ ?- canon_of (X @ _) _ (Z @ _)) ] [ (G ?- assign X W) ] TODO :-
 imply G (Z = W) TODO .

compat [] _ _ [] true _.
compat [A|AS] L Ctx [V|VS] (of V Ta_ARGS V, COMPAT) ARGS :-
 mem Ctx (of_ A Ta _),
 $closed X, app X L Ta', Ta' = Ta, app X ARGS Ta_ARGS,
 compat AS [A|L] Ctx VS COMPAT [V|ARGS].

app F [] F :- !.
app F [X|XS] G :- app (F X) XS G.

mem [X|XS] X :- !.
mem [_|XS] X :- mem XS X.

imply []     G G.
imply [X|XS] G (X => G') :- imply XS G G'.

/*
propapage [ nabla a\ b\ [ of a Ta, of b (Tb a) ] ?- of (X a  b)  (Tc a b) ]
          [                                         of (X V1 V2) Tl       ]
  (COMPAT, (Tc V1 V2) = Tl) :- COMPAT = (of V1 Ta, of V2 (Tb V1)).

propagate [ G ?- of (X # A :: B) T ]
          [   ?- of X # L2 Y ]

 f X + 1
compat [] [] _.
compat [T1|R1] [A|R2] Ctx :-
 mem Ctx (of A Ta), of T1 Ta, ...
               Tb @ Va
*/
% vim: set ft=lprolog:

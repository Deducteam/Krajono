% checks for match branches.
% PTS_inductives invokes conv_case_branch

type conv2_sn term -> stack -> conversion_mode -> term -> stack -> prop.

conv2_sn T1 S1 M T2 S2 :- whd* T1 S1 (_\ T\ S\ comp2 T S M T2 S2).

type conv2_dx term -> stack -> conversion_mode -> term -> stack -> prop.

conv2_dx T1 S1 M T2 S2 :- whd* T2 S2 (_\ T\ S\ comp2 T1 S1 M T S).

type conv2 term -> stack -> conversion_mode -> term -> stack -> prop.

conv2 T1 S1 M T2 S2 :- whd* T1 S1 (_\ T\ S\ conv2_dx T S M T2 S2).

type comp2 term -> stack -> conversion_mode -> term -> stack -> prop.

% removing left arruct (on_case_branch).
comp2 (arr W1 F1) [] (on_case_branch V0 K U0 [V|SN]) U2 S2 :- !,
  pi x\ val x W1 V NF => conv2_sn (F1 x) [] (on_case_branch V0 K U0 SN) U2 S2.

% xi for right arruct (on_case_branch).
comp2 (arr W1 F1) [] (on_case_branch V0 K U0 []) (arr W2 F2) [] :- !,
  conv W1 W2,
  pi x\ conv2 (F1 x) [] (on_case_branch (app V0 x) K U0 []) (F2 x) [].

% final checks (on_case_branch).
comp2 _ S1 (on_case_branch V K U []) U2 S2 :-
  split S1 K _ DX, append DX [V] DXV, comp U DXV eq U2 S2.

type conv_case_branch term -> term -> int -> stack -> term -> term -> prop.

conv_case_branch T1 V0 K SN U0 T2 :-
  conv2 T1 [] (on_case_branch V0 K U0 SN) T2 [].

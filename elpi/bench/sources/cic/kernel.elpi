% Type checker for a generic PTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Global reference R      := identifier

% Closed term: T, U, V, W := sort S        sort S
%                         |  prod     W F  product of type W in F
%                         |  abst     W F  abstraction of type W in F
%                         |  abbr   V W F  abbreviation of V of type W in F
%                         |  appl T A      application of T to list A

% Functional term: F      := function of type T => T

% Closed term list: A     := [] | [V|A]  defined by the system

% Global environment G    := gtop      empty
%                         |  gdec R G  declaration of R after G
%                         |  gdef R G  definition of R after G

% Continuation: C

% Predicates: whd+no+delta T A C     multistep weak head reduct of (appl T A)
%                                    without delta-expansion, passed to continuation C
%             whd+delta+pi T1 A T2   multistep weak head reduction of (appl T1 A) to T2
%                                    with delta-expansion and validating pi-reduction
%             red+whnf T1 A1 T2 A2   reducibility test for generic (appl T1 A1) to whnf (appl T2 A2)
%             conv+main T1 T2        convertibility test for generic T1 and T2
%             conv+args A1 A2        convertibility test for lists of generic arguments A1 and A2
%             conv+whnf U1 A1 U2 A2  convertibility test for whnf's (appl U1 A1) and (appl U1 A1)
%             t+step T U             inference of a type U for T
%           * has+sort T S           test for T having sort S
%             has+checked+type T U   test for T having checked type U
%           * has+type T U           test for T having generic type U
%           * is+valid G             validity test for global environment G

% HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% append A1 A2 A :- $print (append A1 A2 A), fail.

append [] A A.

append [V|A1] A [V|A2] :- append A1 A A2.

% WEAK HEAD COMPUTATION WITHOUT DELTA-EXPANSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% we delay delta-expansion to possibly avoid it.
% whd+no+delta T A C :- $print (whd+no+delta T A C), fail.

% sigma for abbreviation + theta.
whd+no+delta (abbr V W F) A C :- !, pi x\ r+step x V =>
                                          whd+no+delta (F x) A C.
% beta.
whd+no+delta (abst W F) [V|A] C :- !, whd+no+delta (abbr V W F) A C.

% nu.
whd+no+delta (appl T A) A1 C :- !, append A A1 A2,
                                whd+no+delta T A2 C.
% normal form.
whd+no+delta T A C :- C T A.

% WEAK HEAD COMPUTATION WITH PI-REDUCTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% aka eat_prods
% whd+delta+pi T1 A T2 :- $print (whd+delta+pi T1 A T2), fail.

% reflexivity.
whd+delta+pi T [] T :- !.

% beta.
whd+delta+pi (abst W F) [V|A] T2 :- !, whd+delta+pi (abbr V W F) A T2.

% nu.
whd+delta+pi (appl T1 A) A1 T2 :- !, append A A1 A2,
                                  whd+delta+pi T1 A2 T2.
% validating pi.
whd+delta+pi (prod W F) [V|A] T2 :- !, has+checked+type V W,
                                    whd+delta+pi (abbr V W F) A T2.

% sigma for abbreviation + theta.
whd+delta+pi (abbr V W F1) A (abbr V W F2) :- !, pi x\ r+step x V =>
                                                       whd+delta+pi (F1 x) A (F2 x).
% delta.
whd+delta+pi T1 A T2 :- r+step T1 T, !, whd+delta+pi T A T2.

% CONVERSION HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% red+whnf T1 A1 U2 A2 :- $print (red+whnf T1 A1 U2 A2), fail.

red+whnf T1 A1 U2 A2 :- whd+no+delta T1 A1 (conv+whnf U2 A2).

%

% conv+main T1 T2 :- $print (conv+main T1 T2), fail.

conv+main T1 T2 :- whd+no+delta T1 [] (red+whnf T2 []).

%

conv+args [] [].

conv+args [V1|A1] [V2|A2] :- conv+args A1 A2, conv+main V1 V2.

% CONVERSION OF WHNF'S %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% conv+whnf T1 A1 T2 A2 :- $print (conv+whnf T1 A1 T2 A2), fail.

% reflexivity.
conv+whnf T A1 T A2 :- conv+args A1 A2, !.

% xi for product.
conv+whnf (prod W1 F1) [] (prod W2 F2) [] :- !, conv+main W1 W2,
                                             pi x\ conv+main (F1 x) (F2 x).
% xi for abstraction.
conv+whnf (abst W1 F1) [] (abst W2 F2) [] :- !, conv+main W1 W2,
                                             pi x\ conv+main (F1 x) (F2 x).
% candidate left delta.
conv+whnf T1 A1 T2 A2 :- r+step T1 V1, !, maybe+sn T1 V1 A1 T2 A2.

% forced right delta.
conv+whnf T1 A1 T2 A2 :- r+step T2 V2, !, red+whnf V2 A2 T1 A1.

maybe+sn T1 V1 A1 T2 A2 :- r+step T2 V2, !, check+age T1 V1 A1 T2 V2 A2.

% forced left delta.
maybe+sn T1 V1 A1 T2 A2 :- red+whnf V1 A1 T2 A2. 

%

% age-implied left delta.
check+age T1 V1 A1 T2 V2 A2 :- $lt T2 T1, !, red+whnf V1 A1 T2 A2.

% age-implied right delta.
check+age T1 V1 A1 T2 V2 A2 :- red+whnf V2 A2 T1 A1.

% VALIDITY + INFERRED TYPE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

print_hyps :- t+step X W, $print "HYP" X W.

print_hyp X :- t+step X W, $print "HYP" X W.

% t+step T U :- $print (t+step T U), fail.

% S.
t+step (sort S1) (sort S2) :- pts+pair S1 S2.

% N.
t+step (appl T1 A) T :- t+step T1 T2, whd+delta+pi T2 A T.

% Sigma.
t+step (abbr V W F1) (abbr V W F2) :- has+type V W,
                                      pi x\ t+step x W => r+step x V =>
                                      t+step (F1 x) (F2 x).
% X for product.
t+step (prod W F) (sort S3) :- has+sort W S1,
                               pi x\ t+step x W => has+sort (F x) S2,
                               pts+triple S1 S2 S3.
% X for abstraction.
t+step (abst W F1) (prod W F2) :- has+sort W S1,
                                  pi x\ t+step x W =>
                                        (t+step (F1 x) (F2 x), has+sort (F2 x) S2),
                                  pts+triple S1 S2 _.

% TYPE CHECKING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% has+sort T S :- $print (has+sort T S), fail.

% fast path for T being a sort.
has+sort (sort S1) S2 :- !, t+step (sort S1) (sort S2).

has+sort T S :- t+step T U, red+whnf U [] (sort S) [].

%

% has+checked+type T U :- $print (has+checked+type T U), fail.

% fast path for T and U being sorts.
has+checked+type (sort S1) (sort S2) :- !, t+step (sort S1) (sort S2).

% fast path for T and U being sorts.
has+checked+type T (sort S2) :- !, has+sort T S2.

has+checked+type T U :- t+step T X, conv+main X U.

%

% has+type T U :- $print (has+type T U), fail.

has+type T U :- has+sort U _, has+checked+type T U.

% VALIDITY FOR GLOBAL ENVIRONMENTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

is+valid gtop.

% sigma for definition.
is+valid (gdef R G) :- g+line+2 R N V W,
%                       $print constant N R,
                       has+type V W,
                       (r+step R V => t+step R W => is+valid G).
% xi for declaration.
is+valid (gdec R G) :- g+line+1 R N W,
%                       $print constant N R,
                       has+sort W _,
                       (t+step R W => is+valid G).

% KERNEL HELPERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pts+triple S1 S2 S2 :- pts+couple S1 S2.

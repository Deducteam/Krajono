/* combines script1 to script4.
 */

%module main.

%accumulate eval_test, mono_test, poly_test, tr_test, examples.


%-----------------------------
eval_test 1 V :- prog "fib" Fib, eval (Fib @ in 12) V.
eval_test 2 V :- prog "map" Map, prog "fib" Fib,
             eval (Map @ Fib @ (cons @ in 3 @ (cons @ in 6 @ empty))) V.
eval_test 3 V :- prog "app" App,
             eval (App @ (cons @ in 3 @ empty) @ (cons @ in 5 @ empty)) V.
eval_test 4 V :- prog "mem" Mem,
             eval (Mem @ (in 3) @ (cons @ in 5 @ (cons @ in 3 @ empty))) V.
eval_test 5 V :- prog "mem" Mem,
             eval (Mem @ (in 4) @ (cons @ in 5 @ (cons @ in 3 @ empty))) V.
%-----------------------------
eval (fn M)   (fn M).
eval (M @ N)   V :- eval M Fun, eval N U, apply Fun U V.
eval (fixpt R) V :- eval (R (fixpt R)) V.
eval (cond Cond Then Else) V :-
  eval Cond Bool, if (Bool = truth) (eval Then V) (eval Else V).
eval (in N)    (in N).
eval truth     truth.
eval false     false.
eval empty     empty.

eval and     (special and     2 nil).
eval car     (special car     1 nil).
eval cdr     (special cdr     1 nil).
eval cons    (special cons    2 nil).
eval consp   (special consp   1 nil).
eval equal   (special equal   2 nil).
eval greater (special greater 2 nil).
eval minus   (special minus   2 nil).
eval nullp   (special nullp   1 nil).
eval plus    (special plus    2 nil).
eval times   (special times   2 nil).
eval zerop   (special zerop   1 nil).

apply (fn R) U V :- eval (R U) V.
apply (special Fun 1 Args) U V :- !, eval_special Fun (U::Args) V.
apply (special Fun C Args) U (special Fun K (U::Args)) :- K is C - 1.

eval_special car   ((cons @ V @ U)::nil) V.
eval_special cdr   ((cons @ V @ U)::nil) U.
eval_special cons  (U::V::nil) (cons @ V @ U).
eval_special nullp (U::nil) V :- if (U = empty) (V = truth) (V = false).
eval_special consp (U::nil) V :- if (U = empty) (V = false) (V = truth).

eval_special and (B2::B1::nil) V :-
  if (B1 = false) (V = false) (if (B2 = false) (V = false) (V = truth)).
eval_special or  (B2::B1::nil) V :-
  if (B1 = truth) (V = truth) (if (B2 = truth) (V = truth) (V = false)).

eval_special minus ((in N)::(in M)::nil) (in V) :- V is M - N.
eval_special plus  ((in N)::(in M)::nil) (in V) :- V is M + N.
eval_special times ((in N)::(in M)::nil) (in V) :- V is M * N.
eval_special zerop ((in N)::nil) V :- if (N = 0) (V = truth) (V = false).
eval_special equal (B2::B1::nil) V :- if (B1 = B2) (V = truth) (V = false).
eval_special greater ((in N)::(in M)::nil) V :-
  if (M > N) (V = truth) (V = false).
%------------------------------
f Cond Then Else :- Cond, !, Then.
if Cond Then Else :- Else.
%------------------------------
prog "successor"
  (fn x\ plus @ x @ (in 1)).

prog "onep"
  (fn w\ fn u\ fn v\ cond (equal @ (in 1) @ w) u v).

prog "is_sym"
  (fn f\ fn x\ fn y\ equal @ (f @ x @ y) @ (f @ y @ x)).

prog "fib"
  (fixpt fib\ fn n\ cond (zerop @ n) (in 0)
                     (cond (equal @ n @ (in 1)) (in 1)
                           (plus @ (fib @ (minus @ n @ (in 1))) @
                                   (fib @ (minus @ n @ (in 2)))))).

prog "map"
  (fixpt map\ fn f\ fn l\
     cond (nullp @ l) empty
          (cons @ (f @ (car @ l)) @ (map @ f @ (cdr @ l)))).

prog "mem"
  (fixpt mem\ fn x\ fn l\
    cond (nullp @ l) false
         (cond (and @ (consp @ l) @ (equal @ (car @ l) @ x))
                truth (mem @ x @ (cdr @ l)))).

prog "fact"
  (fixpt f\ fn n\ fn m\
    cond (equal @ n @ (in 0)) m
         (f @ (minus @ n @ (in 1)) @ (times @ n @ m))).

prog "app"
  (fixpt app\ fn l\ fn k\
    (cond (nullp @ l) k (cons @ (car @ l) @ (app @ (cdr @ l) @ k)))).

prog "gcd"
  (fixpt f\ fn x\ fn y\
    cond (equal @ (in 1) @ x) (in 1)
         (cond (greater @ y @ x) (f @ y @ x)
               (cond (equal @ x @ y) x (f @ (minus @ x @ y) @ y)))).

prog "ex1"   (cons @ (in 1) @ (in 2)).
prog "ex2"   (plus @ empty @ (in 1)).
prog "ex3"   (cond truth (in 3) empty).
prog "ex4"   (fn x\ fn x\x).
prog "ex5"   (cond truth (in 3) (in 5)).
prog "ex6"   ((fn x\x) @ (fn y\y)).
prog "i"     (fn x\ x).
prog "k"     (fn x\ fn y\x).
prog "s"     (fn x\ fn y\ fn z\ (x @ z) @ (y @ z)).
prog "comp"  (fn f\ fn g\ fn x\ f @ (g @ x)).


main :- eval_test 1 V1.
/*, 
        eval_test 2 V2,
        eval_test 3 V3,
        eval_test 3 V4,
        V1 = in 144, 
        V2 = (cons @ in 2 @ (cons @ in 8 @ empty)),
        V3 = (cons @ in 3 @ (cons @ in 5 @ empty)),
        V = truth,
        mono_test "onep" Ty1,
        mono_test "is_sym" Ty2,
        mono_test "fib" Ty3,
        poly_test "successor" Ty4,
        poly_test "onep" Ty5,
        poly_test "is_sym" Ty6,
        tr_test "successor",
        tr_test "onep",
        tr_test "is_sym". */

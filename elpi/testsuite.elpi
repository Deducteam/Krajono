% vim: syntax=prolog:

/* ============================ testsuite ================================= */
% usage:
% > test            runs all tests
% > solutions t2    generates all solutions of t2

suite TEST t1 "1" :- % runnin of twice in a row should work
  TEST = (of (lam (atom nat) x\ hole) TY T, of T TY1 T1, TY1=TY, T1=T).
suite TEST t2 "1" :- % typing a pi
  TEST = (of (prod (atom nat) x\ hole) TY T).
suite TEST t3 "1" :- % meta/meta unif w pruning: ?X[] = ?Y[v]
  TEST = (of (lam (atom nat) x\ app [atom succ, hole]) TY T,
          of (app [atom succ, hole]) TY1 W,
          dbgpp["before ",T],expect [(T=lam _ (x\app [_,#F1 (A1 x)]),A1=x\[x])],
          unify (app [T,atom zero]) W,
          dbgpp["after  ",T],expect [(T=lam _ (x\app [_,#F2 (A2 x)]),A2=x\[])]).
suite TEST t3-2 "2" :- % meta/meta unif w pruning: ?X[v,r] = ?Y[v,s]
  TEST = (of (lam (atom nat) x\ lam (atom nat) y\ app [atom succ, hole]) _ T1,
          of (lam (atom nat) x\ lam (atom nat) y\ app [atom succ, hole]) _ T2,
          %pp ["before ",T1], pp ["before ",T2],
          expect [(T1=lam _ x\lam _ y\app [_,#F1 (A1 x y)],A1=x\y\[x,y])],
          pi x\ pi y\ of x (atom nat) x => of y (atom nat) y =>
          unify (app [T1, atom zero, x]) (app [T2, atom zero, y]),
          %pp ["after  ",T1], pp ["after  ",T2],
          expect [(T1=lam _ x\lam _ y\app [_, #F2 (A2 x y)],A2=x\y\[x]),
                  (T1=lam _ x\lam _ y\app [_, #F2 (A2 x y)],A2=x\y\[atom zero])]).
suite TEST t3-3 "1" :- % meta/meta unif with dependent type
  TEST = ((pi c\ of c (atom nat) c =>
           pi d\ of d (app [atom vect, c]) d =>
            of hole (TY c d) (X c d)),
          unify (X (atom zero) (atom vnil)) (X (atom zero) (atom vnil)),
          dbgpp ["X=",X],
          expect [%(X = x\y\#F (L x y),L=x\y\[]),
                  (X = x\y\#F (L x y),L=x\y\[x,y])%,
                  %(X = x\y\#F (L x y),L=x\y\[y]),
                  %(X = x\y\#F (L x y),L=x\y\[x])]
]).
suite TEST t3-4 "1" :- % meta/meta unif with dependent type + restriction
  TEST = ((pi c\ of c (atom nat) c =>
           pi d\ of d (app [atom vect, c]) d =>
            of hole (TY c d) (X c d)),
          (pi vn \ of vn (app [atom vect, atom zero]) vn =>
            unify (X (atom zero) (atom vnil)) (X (atom zero) vn)),
          dbgpp["after= ",X],
          expect [%(X=x\y\#F (L x y),L=x\y\[]),
                  (X=x\y\#F (L x y),L=x\y\[x])]).
suite TEST t4 "1" :-
  TEST = (of hole TY1 T1, unify TY1 (atom nat), of hole TY2 T2, unify TY2 set).
suite TEST t5 "1" :-
  TEST = (of (lam hole (x\ x)) (prod (atom nat) x\ atom z) X,
          dbgpp ["X=",X], expect [X=lam _ x\ app [atom nat_to_z, x]]).
suite TEST t6 "2" :-
  TEST = (of hole _ X, unify (app [X, atom zero]) (atom zero),
          dbgpp ["X=",X], expect [(X=lam _ x\ x), (X=lam _ x\ (atom zero))]).
suite TEST t7 "3" :- % delift
  TEST = (of (lam (atom nat) x\ lam (atom nat) y\ hole) _ X,
          unify (app [X, atom zero,atom zero]) (atom zero),
          dbgpp ["X=",X],expect [(X=lam _ x\lam _ y\ x), (X=lam _ x\lam _ y\ y),
                               (X=lam _ x\lam _ y\ atom zero)]).
suite TEST t7-2 "1" :- % delift occur check
  TEST = (of (lam (atom nat) x\ lam (atom nat) y\ hole) _ X,
          not (unify (app [X, atom zero, atom zero]) X)).
suite TEST t7-3 "1" :- % delift  + restriction
  TEST = (of (lam (atom nat) y\ hole) _ (lam _ X),
          of (lam (atom nat) y\ hole) _ (lam _ X1),
          of (lam (atom nat) y\ hole) _ Y,
          pi c\ (of c (atom nat) c :- !) =>
            unify (app [Y, atom zero]) (app [atom succ, X (X1 c)]),
          pp ["X=",X,"\nX1=",X1,"\nY=",Y],
          expect [(X = w\ #F1 (A1 w), A1=w\[w], X1 = w\ #F2 (A2 w), A2=w\[])%,
                  %(X = w\ #F1 (A1 w), A1=w\[],  X1 = w\ #F2 (A2 w), A2=w\[w])
]).
suite TEST t8 "1" :- % whd
  TEST = (SUCC = atom succ, ZERO = atom zero, NAT = atom nat,
          N2 = app [SUCC,app[SUCC,ZERO]],
          MkPi = lam NAT n\rec set n NAT (lam NAT m\lam set ty\ prod NAT w\ ty),
          (pi f\ of f (app [MkPi,N2]) f => of (app [f,ZERO,ZERO]) NAT (Y f))).
% suite TEST t8-1 "1" :- % flex head, BROKEN bubble-up, too many hvs
%   TEST = (NAT = atom nat,
%           (pi c1\ pi c2\ pi c3\ pi t1\ pi t2\
%             of t1 (prod NAT x\set) t1 =>
%             of t2 (prod NAT x\ prod (app [t1,x]) y\set) t2 =>
%             of c1 NAT c1 =>
%             of c2 (app [t1,c1]) c2 => of c3 (app [t2,c1,c2]) c3 =>
%             unify c1 c1 => unif1 c2 c2 => unify c3 c3 =>
%             unify t1 t1 => unify t2 t2 =>
%             copy c1 c1 => unif1 c2 c2 => copy c3 c3 =>
%             copy t1 t1 => copy t2 t2 =>
%             sigma T\sigma TY\
%               of (lam hole f\ app [f,c1,c2,c3]) TY T,
%               pp["T=",T])).
suite TEST t8-2 "4" :- % flex head (esempio e-prod paper CSC + TASSI + ...)
  TEST = (NAT = atom nat, T1 = atom t1, T2 = atom t2, 
          C1 = atom c1, C2 = atom c2, C3 = atom c3,
          (%pi c1\ pi c2\ pi c3\ pi t1\ pi T2\
            (of T1 (prod NAT x\set) T1 :- !) =>
            (of T2 (prod NAT x\ prod (app [T1,x]) y\set) T2 :- !) =>
            (of C1 NAT C1 :- !) =>
            (of C2 (app [T1,C1]) C2 :- !) =>
            (of C3 (app [T2,C1,C2]) C3 :- !) =>
            %sigma T\sigma TY\
              of (lam hole f\ app [atom succ,app [f,C1,C2,C3]]) TY T,
              dbgpp["T=",T])).

run T :- pp ["INFO: running ",T], T.
run T :- pp ["ERROR: failure ",T].
solutions N :- suite T N _, run T.

test :- all-suite [] L, !, all-t L, !, report-t L FAIL,
        if (FAIL=[])
          (pp["\nINFO: All tests passed\n"], $exit "0")
          (pp["\nERROR: Some tests failed: "|FAIL],pp["\n"],$exit"1").
all-suite L [run1 N T _ B _|L1] :-
  suite T N B, not(mem N L), !, all-suite [N|L] L1.
all-suite _ [].
all-t [].
all-t [X|XS] :- X, $incr "sols", fail.
all-t [run1 _ _ N _ U|XS] :-
  $get["sols",N], $reset "sols",
  $get["unexp",U], $reset "unexp",
  all-t XS.
run1 N T _ _ _ :-
  pp["INFO: running ",N], T, $get["sols",S], pp["INFO:   success #",S].
run1 N T _ _ _ :- $get["sols","0"], !, pp ["ERROR:   failure ",N], fail.
report-t [] [].
report-t [run1 N _ "0" _ _|XS] E :- !,
  E = ["\n ",N,"\tNo solution"|ACC], report-t XS ACC.
report-t [run1 N _ X X "0"|XS] ACC :- !, report-t XS ACC.
report-t [run1 N _ X Y "0"|XS] E :- !,
  E = ["\n ",N,"\tWrong number of solutions (",X, " instead of ",Y,")"|ACC],
  report-t XS ACC.
report-t [run1 N _ _ _ _|XS] E :- !,
  E = ["\n ",N,"\tUnexpected solution"|ACC], report-t XS ACC.
expect [X|XS] :- if X true (expect XS).
expect [] :- $get["sols",S],pp["ERROR: Unexpected sol #",S],$incr "unexp",false.



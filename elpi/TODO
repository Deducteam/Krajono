Weird syntax of Teyjus:
- no syntax for negative numbers: ~ 2 is the unary minus applied to 2,
  not the number -2.
- \^['@'-'z'] ???
  \OCTAL \OCTALOCTALOCTAL \xHEX \xHEXHEX
  \\\n
  \xxxxxxx\  where xxx are [ ' ' | '\t' | '\x0b' | '\x0d' ]
  \\cxxxxxx  where xxx are [ ' ' | '\t' | '\x0b' | '\x0d' ]
  eof should be an error
  \x followed by other combinations should be an error
  \ followed by other combinations should be an error

Departures from Teyjus due to camlp5 idiosynchrasies:
- non-associative infix/prefix/postfix behave like their associative
  counterparts. In particular, if @@ and @@@ are two prefix operators
  with @@ > @@@ then (@@ @@@ @@ @@@ a) is parsed nevertheless
- we parse the elements of lists at level 120, that is the first level used
  in pervasives after 110, the level of ","
- i<, r+, etc. are polymorphic in elpi
- Teyjus admits  x :: : type l  and  x = : type y; we don't.
- if the file ends (without eol) inside a comment, the parser ignores the
  comment (in place of returning an error). How??? Same if the query is not
  . terminated.

TODO:
- how does getenv fails in Teyjus when the var is not defined?

Documentation:
- see "Departures from Teyjus"
- remark that we handle constants that start with $ in a special way
- integers are 31 bits; floats are...
- no beta-redexes in the source code
- semantics of ; departed from Teyjus
- strings should not contain newlines; instead
  \n, \b, \t, \r, \\, \", \', "" should be recognized (the last two synonyms)
  <NOT IMPLEMENTED YET>
  \^['@'-'z'] ???
  \OCTAL \OCTALOCTALOCTAL \xHEX \xHEXHEX
  \\\n
  \xxxxxxx\  where xxx are [ ' ' | '\t' | '\x0b' | '\x0d' ]
  \\cxxxxxx  where xxx are [ ' ' | '\t' | '\x0b' | '\x0d' ]
  eof should be an error
  \x followed by other combinations should be an error
  \ followed by other combinations should be an error
  </NOT IMPLEMENTED YET>

TODO:
- update the TODO file

Major Bugs:
- strings need to be quoted when pretty-printed
- revise all the assert false/raise Failure
- string_to_term is severely bugged:
  * we pass the empty amap and cmap when parsing/heapifying the string,
    because we do not have them available. Therefore the function works
    as expected only on closed, meta-closed terms.

Minor Bugs (mostly forward compatibility with Teyjus):
- readterm flushes the rest of the line, even if it should not.
  One of the misteries of camlp5, I suppose :-(
  FIX: as the spec says, we should first read all characters up to dot,
  then parse. Issue: real numbers are problematic :-(
- capture all Invalid_arg exceptions in custom.ml
- capture all exceptions raised from the parser in custom.ml
  (functions string_to_term and readterm)
- revise all remaining assert false, e.g. in parser
- symbols can be declared twice (e.g. in .mod and in .sig): check and avoid
  inserting a duplicated rule. Also issues a camlp5 warning when it happens
  (e.g. in pcf test)
- handle the NotInProlog exception properly
- a precedence level can change associativity if the user declares a symbol
  with it with a new associativity. This is should be avoided, also because
  the pretty-printer does not change the associativity of old symbols.
  Maybe re-use the map used for set_precedence/precedence_of
- we do not check the first argument of "is" and other predicates
- turn =, or, sigma, etc. into Custom predicates?
   In particular, it should not be allowed to add more clauses to them
   via implication.
- turn = into a builtin (more efficient?)


Other:

0. pretty-printing to LaTeX + transformation to standard presentation
   (with fresh variables, etc.)
1. implement delay and experiment with it for:
   a) unif outside the fragment
   b) avoid the creation of Explicit Substitutions ??
   c) avoid failure of the "is" predicate?

Benchmarks:

0. modify lambda3 to use the bound variables (via a list, etc.)
1. http://www.cs.hofstra.edu/~cscccl/lambda-examples/
   vedi lpcic/elpi/doc/termrep.pdf

Possible optimizations:

-1. if full_deref only works on heap terms, why do we pass all that stuff?
    why not calling deref instead?
0. Try alternative implementation for ?n == ?n
   (i.e. go back to the previous unif code, but change to_heap/restrict)
   NOTE: in the WAM the check is for free. An uninstantiated variable
   points to itsefl. So X=X is implemented making X points to X, i.e.
   leaving X uninstantiated. We cannot do that easily for two reasons:
   a) Fields of a constructor cannot be mutated in ocaml <=4.3.
   b) Our variables can occur multiple times applied to different arguments.
      To exploit the WAM's representation we should replace our
      UVar of ... * term list with a UApp (UVar ..., term list) but then
      we need a deep pattern matching everywhere and this could slow down
      again.
   TO BE TRIED (??)
2. the to_heap could keep the highest non-bound variable to be cached in
   the UVar to make restriction linear

CHECKED:
- check if the ,/& and the =>/:- checks slow down a lot. In that case
  we can parse both pairs as just one symbol :-(
  Cvetan: no slow down

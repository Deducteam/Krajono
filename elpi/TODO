Weird syntax of Teyjus:
- no syntax for negative numbers: ~ 2 is the unary minus applied to 2,
  not the number -2.
- strings should not contain newlines; instead
  \n, \b, \t, \n, \r, \\, \", "" should be recognized (the last two synonyms)
  \^['@'-'z'] ???
  \OCTAL \OCTALOCTALOCTAL \xHEX \xHEXHEX
  \\\n
  \xxxxxxx\  where xxx are [ ' ' | '\t' | '\x0b' | '\x0d' ]
  \\cxxxxxx  where xxx are [ ' ' | '\t' | '\x0b' | '\x0d' ]
  eof should be an error
  \x followed by other combinations should be an error
  \ followed by other combinations should be an error
- if the file ends (without eol) inside a comment, the parser ignores the
  comment (in place of returning an error). How??? Same if the query is not
  . terminated.
- binders can be explicitly typed in Teyjus

Departures from Teyjus due to camlp5 idiosynchrasies:
- non-associative infix/prefix/postfix behave like their associative
  counterparts. In particular, if @@ and @@@ are two prefix operators
  with @@ > @@@ then (@@ @@@ @@ @@@ a) is parsed nevertheless
- we parse the elements of lists at level 120, that is the first level used
  in pervasives after 110, the level of ","
- how does getenv fails in Teyjus when the var is not defined?
- i<, r+, etc. are polymorphic in elpi

Documentation:
- see "Departures from Teyjus"
- remark that we handle constants that start with $ in a special way
- integers are 31 bits; floats are...
- no beta-redexes in the source code
- semantics of ; departed from Teyjus

Bugs:
- readterm flushes the rest of the line, even if it should not.
  One of the misteries of camlp5, I suppose :-(
  FIX: as the spec says, we should first read all characters up to dot,
  then parse. Issue: real numbers are problematic :-(
- capture all Invalid_arg exceptions in custom.ml
- capture all exceptions raised from the parser in custom.ml
  (functions string_to_term and readterm)
- revise all remaining assert false, e.g. in parser
- symbols can be declared twice (e.g. in .mod and in .sig): check and avoid
  inserting a duplicated rule. Also issues a camlp5 warning when it happens
  (e.g. in pcf test)
- handle the NotInProlog exception properly
- a precedence level can change associativity if the user declares a symbol
  with it with a new associativity. This is should be avoided, also because
  the pretty-printer does not change the associativity of old symbols.
  Maybe re-use the map used for set_precedence/precedence_of
- we do not check the first argument of "is"
- strings need to be quoted when pretty-printed
- string_to_term is severely bugged:
  * we pass the empty amap and cmap when parsing/heapifying the string,
    because we do not have them available. Therefore the function works
    as expected only on closed, meta-closed terms.

Other:

0. pretty-printing to LaTeX + transformation to standard presentation
   (with fresh variables, etc.)
1. implement delay and experiment with it for:
   a) unif outside the fragment
   b) avoid the creation of Explicit Substitutions ??
   c) avoid failure of the "is" predicate?

Benchmarks:

0. modify lambda3 to use the bound variables (via a list, etc.)
1. http://www.cs.hofstra.edu/~cscccl/lambda-examples/
   vedi lpcic/elpi/doc/termrep.pdf
2. port all examples we have to Teyjus as well
3. port Teyjus pnf.* and its examples to newelpi
4. port Teyjus hc_interp.* to newelpi
   Note: it is outside the fragment and it needs to be brought
   back in.
5. pcf from teyjus does not work. It loops.
6. the proofcert of Tomer was ported, parses successfully, but does gove a solution. To be investigated.

Bugs:

-2. revise all the assert false/raise Failure
0. turn =, or, sigma, etc. into Custom predicates?
   In particular, it should not be allowed to add more clauses to them
   via implication.
0.1. turn = into a builtin (more efficient?)

Possible optimizations:

-2 optimize the case of app_deref where we can stay in the fragment
   after the beta (maybe already done?)
-1. if full_deref only works on heap terms, why do we pass all that stuff?
    why not calling deref instead?
0. Try alternative implementation for ?n == ?n
   (i.e. go back to the previous unif code, but change to_heap/restrict)
   NOTE: in the WAM the check is for free. An uninstantiated variable
   points to itsefl. So X=X is implemented making X points to X, i.e.
   leaving X uninstantiated. We cannot do that easily for two reasons:
   a) Fields of a constructor cannot be mutated in ocaml <=4.3.
   b) Our variables can occur multiple times applied to different arguments.
      To exploit the WAM's representation we should replace our
      UVar of ... * term list with a UApp (UVar ..., term list) but then
      we need a deep pattern matching everywhere and this could slow down
      again.
   TO BE TRIED (??)
2. the to_heap could keep the highest non-bound variable to be cached in
   the UVar to make restriction linear

Kind constant type.

Kind formula type.
Kind flist type.

Type ttrue formula.
Type aand formula -> formula -> formula.
Type oor formula -> formula -> formula.
Type iimp formula -> formula -> formula.
Type ppi (formula -> formula) -> formula.
Type ssigma (formula -> formula) -> formula.
Type pred constant -> flist -> formula.

Type fnil flist.
Type fcons formula -> flist -> flist.

Kind clause type.
Type mk_clause formula -> clause.

/* clause list */
Kind clist type.
Type cnil clist.
Type ccons clause -> clist -> clist.

Kind sequent type.
Type pair clist -> formula -> sequent.

Kind slist type.
Type snil slist.
Type scons sequent -> slist -> slist.


Define match : clause -> formula -> formula -> prop by
  match (mk_clause (ppi F)) Pred Body :=
    exists X, match (mk_clause (F X)) Pred Body
; match (mk_clause (aand F1 F2)) Pred Body :=
    match (mk_clause F1) Pred Body
; match (mk_clause (aand F1 F2)) Pred Body :=
    match (mk_clause F2) Pred Body
; match (mk_clause (iimp Body Pred)) Pred Body.

Define look_in_prog: clist -> formula -> formula -> prop by
  look_in_prog (ccons ClauseHead Tl) Pred ClauseTail := 
    match ClauseHead Pred ClauseTail
; look_in_prog (ccons ClauseHead Tl) Pred G := look_in_prog Tl Pred G.

Define step : clist -> slist -> slist -> prop by
  step Prog (scons (pair Ctx ttrue) AndL) AndL
; step Prog (scons (pair Ctx (aand F1 F2)) AndL) (scons (pair Ctx F1) (scons (pair Ctx F2) AndL))
; step Prog (scons (pair Ctx (oor F1 F2)) AndL) (scons (pair Ctx F1) AndL)
; step Prog (scons (pair Ctx (oor F1 F2)) AndL) (scons (pair Ctx F2) AndL)
; step Prog (scons (pair Ctx (iimp F1 F2)) AndL) (scons (pair (ccons (mk_clause F1) Ctx) F2) AndL)
; nabla x, step Prog (scons (pair Ctx (ppi F)) AndL) (scons (pair Ctx (F x)) AndL)
; step Prog (scons (pair Ctx (ssigma F)) AndL) (scons (pair Ctx (F X)) AndL)
; step Prog (scons (pair Ctx (pred K L)) AndL) (scons (pair Ctx ClauseBody) AndL) :=
    look_in_prog Ctx (pred K L) ClauseBody \/
    look_in_prog Prog (pred K L) ClauseBody.

Define steps : clist -> slist -> slist -> prop by
  steps Prog AndL AndL
; steps Prog AndLI AndLO :=
   exists AndL, step Prog AndLI AndL /\ steps Prog AndL AndLO.

Theorem foo_true: forall Prog, step Prog (scons (pair cnil ttrue) snil) snil.
intros. unfold 1. search.


Theorem foo_pi: forall Prog, nabla y, step Prog (scons (pair cnil (ppi x\ iimp x x)) snil) (scons (pair cnil (iimp y y)) snil).
intros. unfold 6. search.


Theorem foo_and: forall Prog, step Prog (scons (pair cnil (aand ttrue ttrue)) snil) (scons (pair cnil ttrue) (scons (pair cnil ttrue) snil)).
intros. unfold 2. search. 


Theorem foo_or: forall Prog, step Prog (scons (pair cnil (oor ttrue ttrue)) snil) (scons (pair cnil ttrue) snil).
intros. unfold 3. search.


Theorem foo_imp: forall Prog, step Prog (scons (pair cnil (iimp ttrue ttrue)) snil) (scons (pair (ccons (mk_clause ttrue) cnil) ttrue) snil).
intros. unfold 5. search.

Type p constant.
Type q constant.

Theorem test_look_in_prog : 
  look_in_prog 
    (ccons (cpair (pred p fnil) (fcons (pred q fnil) fnil)) cnil)
    (pred p fnil)
    (fcons (pred q fnil) fnil).
unfold 1. unfold 2. search.

Theorem small_big_ok:
 forall Prog F,
  steps Prog (ccons (cpair cnil F) cnil) cnil ->
  { F }.


/*
Theorem test_back_chain: 
  step (ccons (cpair (pred p fnil) 
                (fcons (pred q fnil) fnil)) cnil) 
       (scons (pair fnil (pred p fnil)) snil) 
       (scons (pair fnil (pred q fnil)) snil).
unfold 8.




Prog:= (ccons (cpair (pred p fnil) 
                     (fcons (pred q fnil) fnil)) cnil) 
Ctx := fnil

 
step Prog 
     (scons (pair Ctx (pred K L)) AndL) 
     (scons (pair Ctx (head ClauseBody)) (sappend Rez AndL)) :=
    look_in_prog Prog (pred K L) ClauseBody /\
    create_seq_list Ctx (tail ClauseBody) Rez.

*/

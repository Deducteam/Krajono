% Validator for \lambda\delta version 3 --------------------------------------

% sort: K := user defined

% Layer: L := user defined

% Closed term: T, U, V, W ::= sort   K
%                          |  abbr   T F where F: T => T
%                          |  abst L T F where F: T => T 
%                          |  appl   T T
%                          |  cast   T T

% Global environment: G ::= gtop
%                        |  gdef T F where F: T => G
%                        |  gdec T F where F: T => G

% application stack: S ::= satom
%                       |  scons S V

% RTM mode: M, N := m+0 | m+1 | m+y 

% Predicates: flat+  M           = (M = m+0) or (M = m+y)
%             rtm+1  T S M M S T = reduction and type machine (single step)
%             conv+  T M T M = conversion by levels
%             appl+  T M T M = applicability 
%             tv+    T       = validity for terms
%             gv+    G       = validity for global environments

% Parameters: k+succ K K = successor for sort hierarchy
%             l+zero L   = zero layer
%             l+pos  L   = positive layer
%             l+pred L L = predeccessor for layers
  
% Constants: m+0 = typing not allowed in RTM
%            m+1 = typing required in RTM
%            m+y = typing allowed in RTM (version 2)
%            a+r = restricted applicability (version 1)
%            a+x = extended applicability (version 2)

% AUXILIARY PREDICATES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

flat+ m+0.

% version 2
flat+ m+y.

l+upd m+1 L1 L2 :- l+pred L1 L2.

l+upd M L L :- flat+ M.

% REDUCTION AND TYPE MACHINE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

rtm+1 (appl V T) S M M (scons S V) T :- $print rtm+1_appl.

% beta, epsilon, x, updated for version 3
rtm+1 (abst L1 W T) (scons S V) M M S (abbr V T) :- l+upd M L1 L2, l+pos L2, $print rtm+1_beta.

% e
rtm+1 (cast U T) S m+1 m+0 S U :- $print rtm+1_e.

% epsilon
rtm+1 (cast U T) S M M S T :- flat+ M, $print rtm+1_epsilon.

% s
rtm+1 (sort K1) S m+1 m+0 S (sort K2) :- k+succ K1 K2, $print rtm+1_s.

rtm+1 T1 S M1 M2 S T2 :- prem+ T1 M1 M2 T2, $print rtm+1_lref.

% CONVERSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

stack+ satom satom :- $print stack+_atom.

stack+ (scons S1 V1) (scons S2 V2) :- conv+ V1 satom m+0 m+0 satom V2,
                                      stack+ S1 S2, $print stack+_cons.

conv+ T S1 M M S2 T :- stack+ S1 S2, $print conv+_refl.

% local l, x, updated for version 2 and 3
conv+ (abst L1 W1 T1) satom M1 M2 satom (abst L2 W2 T2) :- l+upd M1 L1 L2, l+pos L2,
                                                           conv+ W1 satom m+0 m+0 satom W2,
                                                           pi x\ prem+ x m+1 m+0 W2 => prem+ x m+y m+y W2 =>
                                                           conv+ (T1 x) satom M1 M2 satom (T2 x),
                                                           $print conv+_abst.

% upsilon, local l, x 
conv+ (abst L1 W T) S1 M1 M2 S2 T2 :- l+upd M1 L1 L, l+zero L,
                                      pi x\ prem+ x m+1 m+0 W => conv+ (T x) S1 M1 M2 S2 T2,
                                      $print conv+_upsilon_sn.

% local delta updated for version 2
conv+ (abbr V T) S1 M1 M2 S2 T2 :- pi x\ prem+ x m+0 m+0 V =>
                                         prem+ x m+1 m+1 V =>
                                         prem+ x m+y m+y V =>
                                   conv+ (T x) S1 M1 M2 S2 T2, $print conv+_abbr_sn.

conv+ T1 S1 M1 M2 S2 T2 :- rtm+1 T1 S1 M1 M S T, conv+ T S M M2 S2 T2, $print conv+_step_sn.

% upsilon, local l, x
conv+ T1 S1 M1 M2 (abst L2 W T) :- l+upd M2 L2 L, l+zero L,
                                   pi x\ prem+ x m+1 m+0 W => conv+ T1 S1 M1 M2 S2 (T x),
                                   $print conv+_upsilon_dx.

% local delta updated for version 2
conv+ T1 S1 M1 M2 S2 (abbr V T) :- pi x\ prem+ x m+0 m+0 V =>
                                         prem+ x m+1 m+1 V =>
                                         prem+ x m+y m+y V =>
                                   conv+ T1 S1 M1 M2 S2 (T x), $print conv+_abbr_dx.

conv+ T1 S1 M1 M2 S2 T2 :- rtm+1 T2 S2 M2 M S T, conv+ T1 S1 M1 M S T, $print conv+_step_dx.

% APPLICABILITY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

appl+ (abst L1 W U) satom M M S V :- l+upd M L1 L, l+pos L, 
                                     conv+ V S m+1 m+0 satom W, $print appl+_refl.

% upsilon, local l
appl+ (abst L1 W T) S1 M1 M2 S2 T2 :- l+upd M1 L1 L, l+zero L,
                                      pi x\ prem+ x m+1 m+0 W => appl+ (T x) S1 M1 M2 S2 T2,
                                      $print appl+_upsilon.

% local delta updated for version 2
appl+ (abbr V T) S1 M1 M2 S2 T2 :- pi x\ prem+ x m+0 m+0 V =>
                                         prem+ x m+1 m+1 V =>
                                         prem+ x m+y m+y V =>
                                   appl+ (T x) S1 M1 M2 S2 T2, $print appl+_abbr.

appl+ T1 S1 M1 M2 S2 T2 :- rtm+1 T1 S1 M1 M S T, appl+ T S M M2 S2 T2, $print appl+_step.

% VALIDITY FOR TERMS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tv+ (sort N) :- $print tv+_sort.

% local delta updated for version 2
tv+ (abbr V T) :- tv+ V, pi x\ tv+ x =>
                               prem+ x m+0 m+0 V =>
                               prem+ x m+1 m+1 V =>
                               prem+ x m+y m+y V =>
                         tv+ (T x), $print tv+_abbr.

% local l updated for version 2 and 3
tv+ (abst L W T) :- tv+ W, pi x\ tv+ x => 
                                 prem+ x m+1 m+0 W =>
                                 prem+ x m+y m+y W =>
                           tv+ (T x), $print tv+_abst.

% restricted applicability condition (version 1) updated for version 3
tv+ (appl V T) :- a+r, tv+ V, tv+ T, appl+ T satom M m+0 satom V, $print tv+_appl_r.

%extended applicability condition (version 2) updated for version 3
tv+ (appl V T) :- a+x, tv+ V, tv+ T, appl+ T satom m+y m+y satom V, $print tv+_appl_x.

tv+ (cast U T) :- tv+ U, tv+ T, conv+ T satom m+1 m+0 satom U, $print tv+_cast.

% VALIDITY FOR GLOBAL ENVIRONMENTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

gv+ gtop :- $print gv+_top. 

% global delta updated for version 2
gv+ (gdef C V G) :- $print constant C,
                    tv+ V, pi x\ tv+ x =>
                                 prem+ x m+0 m+0 V =>
                                 prem+ x m+1 m+1 V =>
                                 prem+ x m+y m+y V =>
                           gv+ (G x), $print gv+_def.

% global l updated for version 2
gv+ (gdec C W G) :- $print constant C,
                    tv+ U, pi x\ tv+ x =>
                                 prem+ x m+1 m+0 W =>
                                 prem+ x m+y m+y W =>
                           gv+ (G x), $print gv+_dec.

% Additional matter ----------------------------------------------------------

% LAYERS FOR PTS, LAMBDA-INFINITY, AUT-68, AUT-QE %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Constants: l+0 = hyper Pi
%            l+1 = Pi
%            l+2 = lambda
%            l+y = lambda-infinity

l+zero l+0. 

l+pos l+1. 

l+pos l+2. 

l+pos l+y. 

l+pred l+0 l+0.

l+pred l+1 l+0.

l+pred l+2 l+1.

l+pred l+y l+y.

% TESTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

test_sta :- k+succ k+1 k+2 => conv+ (sort k+1) satom m+1 m+0 satom  (sort k+2).

test_conv :- conv+ (appl w1 (abst l+y w2 x\ (abst l+y x y\ y))) satom m+0 m+0 satom (abst l+y w1 x\ x).

test_tv_11 :- a+r => k+succ k+1 k+2 => k+succ k+2 k+3 => tv+ (appl (sort k+1) (abst l+y (sort k+2) x\ x)).

test_tv_12 :- a+r => tv+ w => tv+ (abst l+y w x\ cast w x).

test_tv_13 :- a+r => tv+ w => tv+ (cast (abst l+y w x\ w) (abst l+y w x\ x)).

% does fail with resticted applicability
test_tv_2 :- a+x => k+succ k+1 k+2 =>
             tv+ (abst l+y (abst l+y (sort k+2) x\ (sort k+2)) x\ (abst l+y x y\ appl (sort k+1) y)).

% first two lines of the grundlagen: requires version 3
test_gv_3 :- a+x => gv+ (
% constant 1
   (gdef c+1 (abst l+y (sort k+1) a\
             (abst l+y (sort k+1) b\
               (cast (sort k+1) (abst l+1 a x\ b))
             )) l_imp\
% constant 2
   (gdef c+2 (abst l+y (sort k+1) a\ 
             (abst l+y (sort k+1) b\
             (abst l+y a a1\
             (abst l+y (appl b (appl a l_imp)) i\
                (cast b (appl a1 i))
              )))) l_mp\
   gtop))
).

main :- test_sta, test_conv, test_tv_11, test_tv_12, test_tv_13, test_tv_2, test_gv_3.

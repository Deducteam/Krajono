% Validator for \lambda\delta version 3 --------------------------------------

% sort: K := user defined

% Layer: L := user defined

% Closed term: T, U, V, W ::= sort   K                   sort of index K
%                          |  abbr   T F where F: T => T abbreviation of T in F
%                          |  abst L T F where F: T => T L-abstraction of type T in F 
%                          |  appr   T T                 restricted application
%                          |  appx   T T                 extended application
%                          |  cast   T T                 type annotatiuon
% only for RTM:            |  prod L T F where F: T => T updated L-abstraction of type T in F

% Global environment: G ::= gtop                     empty
%                        |  gdef T F where F: T => G definition of T in F
%                        |  gdec T F where F: T => G declaration of type T in F

% application stack: S ::= satom     empty
%                       |  scons S V stacked argument

% RTM mode: M, N := m+0 | m+1 | m+y 

% Predicates: r+exp  T M M T     = reference expansion
%             rtm+0  T S M M S T = extended reduction     (aux)
%             conv+  T S M M S T = extended conversion    (main)
%             conv+r T S M M S T = extended conversion    (aux)
%             conv+0 T S M M S T = extended conversion    (aux)
%             appl+  T S M M S T = extended applicability (main)
%             tv+    T           = validity for terms
%             gv+    G           = validity for global environments

% Parameters: k+succ K K = successor for sort hierarchy
%             l+zero L   = zero layer
%             l+pred L L = predeccessor for layers
  
% Constants: m+0 = typing not allowed in RTM
%            m+1 = typing required in RTM
%            m+y = typing allowed in RTM (version 2)

% EXTENDED REDUCTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

rtm+0 T1 S1 M1 M2 S2 T2 :- before, $print begin-rtm1 T1 S1 M1, fail.

rtm+0 (appr V T) S M M (scons S V) T :- !, $print rtm+0_appr.

rtm+0 (appx V T) S M M (scons S V) T :- !, $print rtm+0_appx.

% beta, epsilon, updated for version 3
rtm+0 (prod L W T) (scons S V) M M S (abbr V T) :- !, $print rtm+0_beta.

% e
rtm+0 (cast U T) S m+1 m+0 S U :- !, $print rtm+0_e.

% epsilon
rtm+0 (cast U T) S m+0 m+0 S T :- !, $print rtm+0_epsilon.

% epsilon, version 2
rtm+0 (cast U T) S m+y m+y S T :- !, $print rtm+0_epsilon.

% s
rtm+0 (sort K1) S m+1 m+0 S (sort K2) :- !, k+succ K1 K2, $print rtm+0_s.

% x
rtm+0 (abst L1 W T) S m+1 m+1 S (prod L2 W T) :- !, l+pred L1 L2, $print rtm+0_x. 

rtm+0 (abst L W T) S m+0 m+0 S (prod L W T) :- !, $print rtm+0_abst_0. 

% version 2
rtm+0 (abst L W T) S m+y m+y S (prod L W T) :- !, $print rtm+0_abst_y. 

% EXTENDED CONVERSION PART 1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

stack+ satom satom :- !, $print stack+_atom.

stack+ (scons S1 V1) (scons S2 V2) :- !, conv+ V1 satom m+0 m+0 satom V2,
                                         stack+ S1 S2, $print stack+_cons.

conv+ T1 S1 M1 M2 S2 T2 :- before, $print begin-conv T1 S1 M1 T2 S2 M2, fail.

conv+ T S1 M M S2 T :- !, stack+ S1 S2, $print conv+_refl.

% upsilon, local l
conv+ (prod L W T1) S1 M1 M2 S2 T2 :- l+zero L, !,
                                      pi x\ r+exp x m+1 m+0 W =>
                                            conv+ (T1 x) S1 M1 M2 S2 T2,
                                      $print conv+_prod.

% local delta, updated for version 2
conv+ (abbr V T1) S1 M1 M2 S2 T2 :- !, pi x\ r+exp x m+0 m+0 V =>
                                             r+exp x m+1 m+1 V =>
                                             r+exp x m+y m+y V =>
                                             conv+ (T1 x) S1 M1 M2 S2 T2,
                                       $print conv+_abbr.

conv+ T1 S1 M1 M2 S2 T2 :- rtm+0 T1 S1 M1 M S T, !, conv+ T S M M2 S2 T2, $print conv+_step.

conv+ T1 S1 M1 M2 S2 T2 :- conv+r T2 S2 M2 M1 S1 T1.

% EXTENDED CONVERSION PART 2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

conv+l T S1 M M S2 T :- !, stack+ S1 S2, $print conv+l_refl.

% upsilon, local l
conv+l (prod L W T1) S1 M1 M2 S2 T2 :- l+zero L, !, 
                                       pi x\ r+exp x m+1 m+0 W =>
                                             conv+l (T1 x) S1 M1 M2 S2 T2,
                                       $print conv+r_prod.

% local delta, updated for version 2
conv+l (abbr V T1) S1 M1 M2 S2 T2 :- !, pi x\ r+exp x m+0 m+0 V =>
                                              r+exp x m+1 m+1 V =>
                                              r+exp x m+y m+y V =>
                                              conv+l (T1 x) S1 M1 M2 S2 T2,
                                        $print conv+l_abbr.

conv+l T1 S1 M1 M2 S2 T2 :- rtm+0 T1 S1 M1 M S T, !, conv+l T S M M2 S2 T2, $print conv+l_step.

conv+l T1 S1 M1 M2 S2 T2 :- conv+0 T1 S1 M1 M2 S2 T2.

% EXTENDED CONVERSION PART 3 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

conv+r T S1 M M S2 T :- !, stack+ S1 S2, $print conv+r_refl.

% upsilon, local l
conv+r (prod L W T1) S1 M1 M2 S2 T2 :- l+zero L, !, 
                                       pi x\ r+exp x m+1 m+0 W =>
                                             conv+r (T1 x) S1 M1 M2 S2 T2,
                                       $print conv+r_prod.

% local delta, updated for version 2
conv+r (abbr V T1) S1 M1 M2 S2 T2 :- !, pi x\ r+exp x m+0 m+0 V =>
                                              r+exp x m+1 m+1 V =>
                                              r+exp x m+y m+y V =>
                                              conv+r (T1 x) S1 M1 M2 S2 T2, 
                                        $print conv+r_abbr.

conv+r T1 S1 M1 M2 S2 T2 :- rtm+0 T1 S1 M1 M S T, !, conv+r T S M M2 S2 T2, $print conv+r_step.

conv+r T1 S1 M1 M2 S2 T2 :- conv+0 T2 S2 M2 M1 S1 T1.

% EXTENDED CONVERSION PART 4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

conv+0 T1 S1 M1 M2 S2 T2 :- before, $print begin-conv0 T1 S1 M1 T2 S2 M2, fail.

conv+0 T S1 M M S2 T :- !, stack+ S1 S2, $print conv+0_refl.

% local l, updated for version 2 and 3
conv+0 (prod L W1 T1) satom M1 M2 satom (prod L W2 T2) :- !, conv+ W1 satom m+0 m+0 satom W2,
                                                             pi x\ r+exp x m+1 m+0 W2 =>
                                                                   r+exp x m+y m+y W2 =>
                                                                   conv+ (T1 x) satom M1 M2 satom (T2 x),
                                                             $print conv+0_abst.

conv+0 T1 S1 M1 M2 S2 T2 :- r+exp T1 M1 M T, !, conv+l T S1 M M2 S2 T2, $print conv+0_sn.

conv+0 T1 S1 M1 M2 S2 T2 :- r+exp T2 M2 M T, conv+r T S2 M M1 S1 T1, $print conv+0_dx.

% , ok+l T1 M2 T2,

ok_l T1 M2 T2 :- r+exp T2 M2 M T, !, $lt T2 T1.

ok_l T1 M2 T2.

% EXTENDED APPLICABILITY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

appl+ T1 S M T2 :- before, $print begin-appl T1 S M, fail.

% upsilon, local l
appl+ (prod L W T1) S M T2 :- l+zero L, !, 
                              pi x\ r+exp x m+1 m+0 W =>
                                    appl+ (T1 x) S M T2,
                              $print appl+_prod.

% local delta, updated for version 2
appl+ (abbr V T1) S M T2 :- !, pi x\ r+exp x m+0 m+0 V =>
                                     r+exp x m+1 m+1 V =>
                                     r+exp x m+y m+y V =>
                                     appl+ (T1 x) S M T2,
                               $print appl+_abbr.

appl+ (prod L W U) satom M V :- !, conv+ V satom m+1 m+0 satom W, $print appl+_conv.

appl+ T1 S1 M1 T2 :- rtm+0 T1 S1 M1 M S T, !, appl+ T S M T2, $print appl+_step.

appl+ T1 S M1 T2 :- r+exp T1 M1 M2 T, !, appl+ T S M2 T2, $print appl+_exp.

% VALIDITY FOR TERMS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tv+ T :- before, $print begin-tv T, fail.

tv+ (sort N) :- !, $print tv+_sort.

% local delta updated for version 2
tv+ (abbr V T) :- !, tv+ V,
                     pi x\ (tv+ x :- !) =>
                           r+exp x m+0 m+0 V =>
                           r+exp x m+1 m+1 V =>
                           r+exp x m+y m+y V =>
                           tv+ (T x),
                     $print tv+_abbr.

% local l updated for version 2 and 3
tv+ (abst L W T) :- !, tv+ W,
                       pi x\ (tv+ x :- !) =>
                             r+exp x m+1 m+0 W =>
                             r+exp x m+y m+y W =>
                             tv+ (T x),
                       $print tv+_abst.

% restricted applicability condition (version 1) updated for version 3
tv+ (appr V T) :- !, tv+ V, tv+ T, appl+ T satom m+1 V, $print tv+_appl_r.

%extended applicability condition (version 2) updated for version 3
tv+ (appx V T) :- !, tv+ V, tv+ T, appl+ T satom m+y V, $print tv+_appl_x.

tv+ (cast U T) :- tv+ U, tv+ T, conv+ T satom m+1 m+0 satom U, $print tv+_cast.

% VALIDITY FOR GLOBAL ENVIRONMENTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

gv+ G :- before, $print begin-gv G, fail.

gv+ gtop :- $print gv+_top. 

% global delta updated for version 2
gv+ (gdef C V G) :- $print constant C,
                    tv+ V, 
                    pi x\ (tv+ x :- !) =>
                          r+exp x m+0 m+0 V =>
                          r+exp x m+1 m+1 V =>
                          r+exp x m+y m+y V =>
                          gv+ (G x),
                    $print gv+_def.

% global l updated for version 2
gv+ (gdec C W G) :- $print constant C,
                    tv+ U,
                    pi x\ (tv+ x :- !) =>
                          r+exp x m+1 m+0 W =>
                          r+exp x m+y m+y W =>
                          gv+ (G x),
                    $print gv+_dec.

% Additional matter ----------------------------------------------------------

% LAYERS FOR PTS, LAMBDA-INFINITY, AUT-68, AUT-QE %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Constants: l+0 = hyper Pi
%            l+1 = Pi
%            l+2 = lambda
%            l+y = lambda-infinity

l+zero l+0. 

l+pred l+0 l+0 :- !.

l+pred l+1 l+0 :- !.

l+pred l+2 l+1 :- !.

l+pred l+y l+y.

% TESTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

test_sta :- k+succ k+1 k+2 => conv+ (sort k+1) satom m+1 m+0 satom (sort k+2).

test_conv :- conv+ (appr w1 (abst l+y w2 x\ (abst l+y x y\ y))) satom m+0 m+0 satom (abst l+y w1 x\ x).

test_tv_11 :- k+succ k+1 k+2 => k+succ k+2 k+3 => tv+ (appr (sort k+1) (abst l+y (sort k+2) x\ x)).

test_tv_12 :- tv+ w => tv+ (abst l+y w x\ cast w x).

test_tv_13 :- tv+ w => tv+ (cast (abst l+y w x\ w) (abst l+y w x\ x)).

% does fail with resticted applicability
test_tv_2 :- k+succ k+1 k+2 =>
             tv+ (abst l+y (abst l+y (sort k+2) x\ (sort k+2)) x\ (abst l+y x y\ appx (sort k+1) y)).

% first two lines of the grundlagen: requires version 3
test_gv_3 :- gv+ (
% constant 1
   (gdef c+1 (abst l+y (sort k+1) a\
             (abst l+y (sort k+1) b\
               (cast (sort k+1) (abst l+1 a x\ b))
             )) l_imp\
% constant 2
   (gdef c+2 (abst l+y (sort k+1) a\ 
             (abst l+y (sort k+1) b\
             (abst l+y a a1\
             (abst l+y (appx b (appx a l_imp)) i\
                (cast b (appx a1 i))
             )))) l_mp\
% constant 3
   (gdef c+3 (abst l+2 (sort k+1) a\
                (cast (appx a (appx a l_imp)) (abst l+2 a x\ x))
             ) l_refimp\
   gtop)))
).

main :- test_sta, test_conv, test_tv_11, test_tv_12, test_tv_13, test_tv_2, test_gv_3.

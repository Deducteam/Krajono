% Validity for \lambda\delta version 1

% Closed terms: T ::= sort N
%                  |  abbr T F where F: T => T
%                  |  abst T F where F: T => T 
%                  |  appl T T
%                  |  cast T T
%
% Predicates: h    = sort hierarchy parameter
%             copy = copying
%             rtm1 = reduction and type machine (single step)
%             rtm  = reduction and type machine (multiple step)
%             conv = conversion by levels
%             comp = comparator by levels
%             tv   = validity for terms
%             gv   = validity global environments
%
% Constants: m+0 = typing not allowed in RTM
%            m+1 = typing required in RTM

% COPYING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

copy (sort N) (sort N).

copy (abbr V1 T1) (abbr V2 T2) :- copy V1 V2, pi x\ copy x x => copy (T1 x) (T2 x).

copy (abst W1 T1) (abst W2 T2) :- copy W1 W2, pi x\ copy x x => copy (T1 x) (T2 x).

copy (appl V1 T1) (appl V2 T2) :- copy V1 V2, copy T1 T2.

copy (cast U1 T1) (appl U2 T2) :- copy U1 U2, copy T1 T2.

% REDUCTION AND TYPE MACHINE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

rtm1 M (appl V T1) M (appl V T2) :- rtm1 M T1 M T2. 

%delta, zeta
% delta is copy (T1 x) (T x)
% zeta  is T x = T2
% so we do NOT see this as a hack to remain in the fragment
rtm1 M (abbr V T1) M T2 :- pi x\ copy x V => (copy (T1 x) (T x), T x = T2).

% beta, epsilon
rtm1 M (appl V (abst W T)) M (abbr V T).

%theta
rtm1 M (appl V1 (abbr V2 T)) M (abbr V2 (appl V1 T)).

%epsilon
rtm1 m+0 (cast U T) m+0 T.

%e
rtm1 m+1 (cast U T) m+0 U.

%s
rtm1 m+1 (sort N1) m+0 (sort N2) :- h N1 N2.

rtm M T M T.

rtm M1 T1 M2 T2 :- rtm1 M1 T1 M T, rtm M T M2 T2.

% CONVERSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

conv M1 U1 M2 U2 :- rtm M1 U1 N1 T1, rtm M2 U2 N2 T2, comp N1 T1 N2 T2.

comp N T N T.

comp N1 (appl V1 T1) N2 (appl V2 T2) :- conv N1 T1 N2 T2, conv m+0 V1 m+0 V2.

comp N1 (abst W1 T1) N2 (abst W2 T2) :- conv m+0 W1 m+0 W2,
                                        pi x\ rtm1 m+1 x m+0 W2 => conv N1 (T1 x) N2 (T2 x).

% VALIDITY FOR TERMS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tv (sort N).

tv (abbr V T) :- tv V, pi x\ tv x => rtm1 M x M V => tv (T x).

tv (abst W T) :- tv W, pi x\ tv x => rtm1 m+1 x m+0 W => tv (T x).

tv (appl V T) :- tv V, tv T, rtm M T m+0 (abst W U), conv m+1 V m+0 W.

tv (cast U T) :- tv U, tv T, conv m+1 T m+0 U.

% VALIDITY FOR GLOBAL CONTEXTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

gv gtop. 

gv (gdef T G) :- tv T, pi x\ tv x => rtm1 M x M T => gv (G x).

gv (gdec U G) :- tv U, pi x\ tv x => rtm1 m+1 x m+0 U => gv (G x).

% TESTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

test_sta :- h n1 n2 => conv m+1 (sort n1) m+0 (sort n2).

test_conv :- conv m+0 (appl w1 (abst w2 x\ (abst x y\ y))) m+0 (abst w1 x\ x).

test_tv_1 :- h n1 n2 => h n2 n3 => tv (appl (sort n1) (abst (sort n2) x\ x)).

test_tv_2 :- tv w => tv (abst w x\ cast w x).

test_tv_3 :- tv w => tv (cast (abst w x\ w) (abst w x\ x)).

main :- test_sta, test_conv, test_tv_1, test_tv_2, test_tv_3.

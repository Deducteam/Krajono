Other:

0. pretty-printing to LaTeX + transformation to standard presentation
   (with fresh variables, etc.)

Benchmarks:

0. modify lambda3 to use the bound variables (via a list, etc.)
1. http://www.cs.hofstra.edu/~cscccl/lambda-examples/
   vedi lpcic/elpi/doc/termrep.pdf
2. port all examples we have to Teyjus as well
3. port Teyjus pnf.* and its examples to newelpi
4. port Teyjus hc_interp.* to newelpi
   Note: it is outside the fragment and it needs to be brought
   back in.

Bugs:

0. turn =, or, etc. into Custom predicates?
1. fix pretty-printing of constants e.g. X = x\x
2. a & b :- c  is parsed incorrectly (wrong precedence)
   and not at all in the toplevel

Possible optimizations:

0. Try alternative implementation for ?n == ?n
   (i.e. go back to the previous unif code, but change to_heap/restrict)
   NOTE: in the WAM the check is for free. An uninstantiated variable
   points to itsefl. So X=X is implemented making X points to X, i.e.
   leaving X uninstantiated. We cannot do that easily for two reasons:
   a) Fields of a constructor cannot be mutated in ocaml <=4.3.
   b) Our variables can occur multiple times applied to different arguments.
      To exploit the WAM's representation we should replace our
      UVar of ... * term list with a UApp (UVar ..., term list) but then
      we need a deep pattern matching everywhere and this could slow down
      again.
   TO BE TRIED (??)
2. optimize neck-cuts during the indexing phase (? maybe not easy/possible)
3. the to_heap could keep the highest non-bound variable to be cached in
   the UVar to make restriction linear
4. compact representation of UVar^d c1 ... cn

Missing:
1. occur-check
2. full lambda-prolog

=============================================

How to implement substitution:

- in full lambda-prolog:
  reduce (app (lam F) T) (F T).

- in the fragment: using the copy clause.
  reduce (app (lam F) T) R :- pi x\ copy x T => copy (F x) (R' x), R = R' x.

  copy (app M N) (app M2 N2) :- copy M M2, copy N n2.
  copy (lam F) (lam F2) :- pi x\ copy x x => copy (F x) (F2 x).

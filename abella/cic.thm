Specification "cic".
Define irl: olist -> prop by
  irl nil ;
  nabla x, irl (of x T x :: L x) := nabla x, irl (L x) ;
  nabla x, irl (copy x x :: L) := irl L.

/*Define var: tm -> prop by
  nabla x, var x.*/

Theorem member_irl: forall G I,
 irl G -> member I G ->
  (exists x T, /*var x /\*/ I = of x T x) \/ (exists x, /*var x /\*/ I = copy x x).
induction on 1. intros. case H1. case H2.
/*of*/
case H2. search. apply IH to H3 H4. search.
/*copy*/
case H2. search. apply IH to H3 H4. search.

Theorem $copy_ok_aux : 
 (forall G R N F, nabla x, irl G ->
   { G, copy x N |- copy (F x) R } -> R = F N) /\
 (forall G R N F, nabla x, irl G ->
   { G, copy x N |- list2 copy (F x) R } -> R = F N).
induction on 2 2.
split. intros. copy: case H2.
/*set*/ search.
/*lam*/
  apply IH to _ copy.
  apply IH to _ copy1.
  search.
/*prod*/
  apply IH to _ copy.
  apply IH to _ copy1.
  search.
/*app*/
  apply IH1 to _ copy.
  search.
/*context*/
  case copy1.
    case copy. search.
    apply member_irl to H1 H3. case H4. case copy. case copy. search.
/*second lemma*/
intros. copy: case H2. search.
/*xcons*/
  apply IH to _ copy.
  apply IH1 to _ copy1.
  search.
/*bad context*/
  case copy1. case copy. apply member_irl to H1 H3. case H4.
  case copy. case copy.

Split $copy_ok_aux as copy_ok, copy_list_ok.

Theorem of_meta : forall M S Ty Ty2 N G1 G2 X, nabla x y z,
 irl G1 -> irl G2 ->
 { of x S x |- of (M x) (Ty x) (M x) } ->
 { G1, copy y N |- copy (M y) X } ->
 { G2 |- of N S N } ->
 { G2, copy z N |- copy (Ty z) Ty2 } ->
 { G2 |- of X Ty2 X }.
intros Irl1 Irl2 Canon SubT ofN SubTY.
apply copy_ok to Irl1  SubT.
apply copy_ok to Irl2 SubTY.
inst Canon with n1 = N.
cut H1 with ofN.
search.

Define ctx: olist -> prop by
  ctx nil ;
  nabla x, ctx (of x T x :: L x) := nabla x, ctx (L x) ;
  nabla x, ctx (copy x (N x) :: L) := ctx L.

Define var: tm -> prop by
  nabla x, var x.

Theorem member_ctx: forall G I,
 ctx G -> member I G ->
  (exists x T, var x /\ I = of x T x) \/
  (exists x N, var x /\ I = copy x N).
induction on 1. intros. case H1. case H2.
/*of*/
case H2. search. apply IH to H3 H4. search.
/*copy*/
case H2. search. apply IH to H3 H4. search.

% Theorem reflexive_copy: forall G N, { G |- copy N N }.
Theorem out_of_scope_member : forall G T, nabla x,
  member (copy x (T x)) G -> false.
induction on 1. intros. case H1. apply IH to H2.

Theorem $copy_ok_aux2 : 
 (forall G R N F, nabla x, ctx G ->
   { G, copy x N |- copy (F x) R } ->
     exists H, { G |- copy H R } /\ H = F N ) /\
 (forall G R N F, nabla x, ctx G ->
   { G, copy x N |- list2 copy (F x) R } ->
    exists H, { G |- list2 copy H R } /\ H = F N).
induction on 2 2.
split. intros. copy: case H2.
/*set*/ search.
/*lam*/
  apply IH to _ copy.
  apply IH to _ copy1.
  search.
/*prod*/
  apply IH to _ copy.
  apply IH to _ copy1.
  search.
/*app*/
  apply IH1 to _ copy.
  search.
/*context*/
  case copy1.
    case copy. skip.
    apply member_ctx to H1 H3. case H4. case copy. case H5. case copy. search.
    apply out_of_scope_member to H3.
/*second lemma*/
intros. copy: case H2. search.
/*xcons*/
  apply IH to _ copy.
  apply IH1 to _ copy1.
  search.
/*bad context*/
  case copy1. case copy. apply member_ctx to H1 H3. case H4.
  case copy. case H5. case copy.
  apply out_of_scope_member to H3.

Split $copy_ok_aux as copy_ok2, copy_list_ok2.

Theorem of_meta2 : forall M S Ty N G0 G2, nabla x,
 ctx (G0 x) -> ctx G2 ->
 { G0 x, of x S x |- of (M x) (Ty x) (M x) } ->
 { G2 |- of N S N } ->
 { G0 N |- of (M N) (Ty N) (M N) }.
skip.

Theorem copy_copy : forall G N T1 T2, nabla x,
 { G, copy x N |- copy (T1 x) (T2 x) } ->
  { G |- copy (T1 N) (T2 N) }.
intros. assert { copy N N }. skip. inst H1 with n1 = N. cut H3 with H2. search.

/*Theorem of_meta2 : forall M M' S Ty Ty' N G0 G0' G2, nabla x,
 ctx (G0 x) -> ctx G2 ->
 { G0 x, of x S x |- of (M x) (Ty x) (M x) } ->
 { G2 |- of N S N } ->
 { G0' |- of M' Ty' M' } /\ M' = M N /\ Ty' = Ty N /\ G0' = G0 N.
skip.*/

Define appendctx: olist -> olist -> olist -> prop by
  appendctx nil nil nil.

Define compat: olist -> olist -> prop by
  compat nil nil ;
  /* How do I say that G1 does not occur in x??? */
  nabla x, compat (of x Ty x :: G0 x) (copy x N :: G1) := compat (G0 N) G1. 

Theorem of_meta3 : forall M Ty Ty2 G0 G1 /*G2 G3*/ X,
 ctx G0 -> ctx G1 -> compat G0 G1 -> /*ctx G2 ->*/
 { G0 |- of M Ty M } ->
 { G1 |- copy M X } ->
 /* ... { G2 |- of N S N } ... -> */
 /*appendctx G1 G2 G3 ->*/
 { G1 /*G3*/ |- copy Ty Ty2 } ->
 { G1 /*G3*/ |- of X Ty2 X }.
induction on 3. intros Ctx0 Ctx1 Compat Canon CopyB CopyTy.
Compat: case Compat.
/*nil*/ apply copy_ok to _ CopyB. skip.
/*of*/ Ctx: case Ctx0. Ctx: case Ctx1.
OfN: assert { of N Ty1 N }. skip.
Canon: apply of_meta2 to Ctx Ctx1 Canon OfN with x = n1.
CopyB: apply copy_copy to CopyB.
Ctx: assert ctx (G2 N). skip.
apply IH to Ctx2 Ctx1 Compat Canon1 CopyB1 _.

booooo !!!!!!!!!!!!!!!!

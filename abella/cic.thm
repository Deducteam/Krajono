Specification "metacic".
Import "copy".
Import "lib".

/**** The theory ****/

Define typing_context: olist -> prop by
  typing_context nil ;
  nabla x, typing_context (copy x x :: of x Ty x :: G x) :=
   nabla x, typing_context (G x).

Define var_decl: o -> prop by
  nabla x, var_decl (of x T x).

Theorem member_typing_context: forall X G,
 typing_context G -> member X G -> var_decl X \/ exists x, X = copy x x.
induction on 1. intros. case H1. case H2. case H2. search. case H4. search.
apply IH to H3 H5. case H6. search. search.

Theorem member_typing_context2: forall Ty G, nabla x,
 typing_context (G x) -> member (of x Ty x) (G x) -> member (copy x x) (G x).
induction on 1. intros. case H1. case H2.
 case H2. case H4. apply IH to H3 H5. search. search.

Theorem typing_context_to_irl: forall G,
 typing_context G -> irl G.
induction on 1. intros. case H1. search. apply IH to H2. search.

Theorem appendctx_to_is_olist: forall L1 L2 L3,
 appendctx L1 L2 L3 -> is_olist L2 -> is_olist L3.
induction on 1. intros. case H1. search. apply IH to H3 _. search.

Theorem irl2_inversion: forall L G, nabla x,
 is_olist (L x) ->
 irl2 (L x) (G x) -> exists L2, free x L2 /\ is_olist L2 /\
  (forall X, member X (L x) -> member X L2 \/ X = is_term x) /\
  (forall X, member X L2 -> member X (L x)).
induction on 1. intros. case H1.
 search.
 apply IH to H3 _ with G = G.
  case H2. unfold. intros. apply H4 to _ with X = X n1. case H6. search. search.
  case H4 (keep). case H2. apply H8 to _ with X = HD n1. case H9.
   exists (is_term n2 :: L1 n2). split.
    search.
    search.
    intros. case H11. search. apply H6 to H12. case H13. search. search.
    intros. case H11. search. apply H7 to H12. search.
 apply IH to H3 _ with G = G.
  unfold. intros. apply H6 to H11. case H12.
   apply member_restrict to H13. apply H8 to _ with X = X1. search.
   search.
  case H11 (keep). exists L4. split.
   search.
   search.
   intros. case H15. search. apply H13 to H16. case H17. search. search.
   intros. apply H14 to H15. search.

Theorem well_typed_to_irl2:
 forall G N M Ty, typing_context G -> { G |- of N Ty M } ->
  exists L, { L |- is_term M } /\ irl2 L G /\ is_olist L.
induction on 2. intros. case H2.
/* coerce */
 apply IH to _ H3.
 case H4.
  search.
  apply member_typing_context to H1 H9. case H10. case H11. case H8. case H8.
/* implicit */
 apply copy_eq to _ H6. backchain typing_context_to_irl.
  apply IH to _ H5. search.
/* lam */
 apply IH to _ H3. apply IH to _ H4.
 apply irl2_inversion to _ H9 with x = n1. case H11.
 apply append_functional to _ with G1 = L, G2 = L3.
 monotone H5 with G3. intros. backchain member_appendctx1.
 monotone H8 with (is_term n1 :: G3). intros.
 apply H13 to H17. case H18. unfold 2. backchain member_appendctx2. search.
 exists G3. split. search.
  apply irl2_appendctx to _ _ H15 with G = G.
   unfold. intros. apply H14 to H18. case H9. apply H20 to H19. case H21.
    case H22. case H23. search.
   search.
  apply appendctx_to_is_olist to H15 _. search.
/* prod */
 apply IH to _ H3. apply IH to _ H4.
 apply irl2_inversion to _ H9 with x = n1. case H11.
 apply append_functional to _ with G1 = L, G2 = L3.
 monotone H5 with G3. intros. backchain member_appendctx1.
 monotone H8 with (is_term n1 :: G3). intros.
 apply H13 to H17. case H18. unfold 2. backchain member_appendctx2. search.
 exists G3. split. search.
  apply irl2_appendctx to _ _ H15 with G = G.
   unfold. intros. apply H14 to H18. case H9. apply H20 to H19. case H21.
    case H22. case H23. search.
   search.
  apply appendctx_to_is_olist to H15 _. search.
/* app */
skip.
/* set */
 exists nil. split. search. unfold. intros. case H3. search.
/* lookup */
 apply member_typing_context to H1 H4. case H5.
  case H6. case H3. apply member_typing_context2 to H1 H4.
   exists (is_term n1 :: nil). split. search. unfold. intros. case H8. search.
   case H9. search.
  case H3.

Define tmfree: tm -> tm -> prop by
 nabla x, tmfree x T.

Theorem irl2_cons: forall L G, nabla x,
 irl2 L G -> irl2 (is_term x :: L) (copy x x :: G).
intros. case H1. unfold. intros. case H3. search. apply H2 to H4. case H5.
search. search.

Theorem transitive_unify: forall G T1 T2 T3,
 { G |- unify T1 T2 } -> { G |- unify T2 T3 } -> { G |- unify T1 T3 }.
skip.

Theorem reflexive_unify: forall G T, { G |- unify T T }.
search.
/*induction on 1. intros. case H1.
 search.
 apply IH to H3 _. apply IH to H4 _ with G = copy n1 n1 :: G.
  apply irl2_cons to H2. search. search.
 apply IH to H3 _. apply IH to H4 _ with G = copy n1 n1 :: G.
  apply irl2_cons to H2. search. search.
 skip.
 case H2. apply H5 to H4. case H6. case H3.*/

Theorem variable_typing_inversion: forall G T, nabla x,
 typing_context (G x) -> { G x |- of x (T x) x } ->
  exists Ty,
   tmfree x Ty /\  member (of x Ty x) (G x) /\ { G x |- unify Ty (T x) }.
induction on 2. intros. case H2.
 case H4.
  apply IH to _ H3. case H6. apply transitive_unify to H8 H5. search.
 apply member_typing_context to H1 H6. case H7.
  case H8. case H5. case H5. case H5.
 apply member_typing_context to H1 H4. case H5. case H6.
  case H3. case H3. apply reflexive_unify with G = G n1, T = T n1. search.
  case H3.

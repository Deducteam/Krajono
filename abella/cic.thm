Specification "cic".

Define is_term: tm -> prop by
  is_term set ;
  is_term (lam T B) := is_term T /\ nabla x, is_term (B x) ;
  is_term (prod T B) := is_term T /\ nabla x, is_term (B x) ;
  is_term (app (xcons T xnil)) := is_term T ;
  is_term (app (xcons T L)) := is_term T /\ is_term (app L).

Theorem copy_lam: forall T1 T2 B1 B2, nabla (x:tm),
 { copy T1 T2 } -> (nabla x, { copy (B1 x) (B2 x) }) ->
 { copy (lam T1 B1) (lam T2 B2) }.
skip.
 
Theorem copy_prod: forall T1 T2 B1 B2, nabla (x:tm),
 { copy T1 T2 } -> (nabla x, { copy (B1 x) (B2 x) }) ->
 { copy (prod T1 B1) (prod T2 B2) }.
skip.

Theorem copy_app_cons: forall T1 T2 L1 L2,
 { copy T1 T2 } -> { copy (app L1) (app L2) } ->
  { copy (app (xcons T1 L1)) (app (xcons T2 L2)) }.
skip.

Theorem copy_M_M: forall M, is_term M -> { copy M M }.
 induction on 1. intros. case H1.
  search.
  apply IH to H2. apply IH to H3. backchain copy_lam with x = n1.
  apply IH to H2. apply IH to H3. backchain copy_prod with x = n1.
  apply IH to H2. search.
  apply IH to H2. apply IH to H3. backchain copy_app_cons.

Define irl: olist -> prop by
  irl nil ;
  nabla x, irl (of x T x :: L x) := nabla x, irl (L x) ;
  nabla x, irl (copy x x :: L) := irl L.

Theorem member_irl: forall G I,
 irl G -> member I G -> (exists x T, I = of x T x) \/ (exists x, I = copy x x).
induction on 1. intros. case H1. case H2.
/*of*/
case H2. search. apply IH to H3 H4. search.
/*copy*/
case H2. search. apply IH to H3 H4. search.

Theorem $copy_eq_aux:
 (forall M N G, irl G -> { G |- copy M N } -> M = N) /\
 (forall L1 L2 G, irl G -> {G |- list2 copy L1 L2} -> L1 = L2).
induction on 2 2. split.
intros. case H2.
 search.
 apply IH to _ H3. inst H4 with n2 = n1. apply IH to _ H5. search.
 apply IH to _ H3. inst H4 with n2 = n1. apply IH to _ H5. search.
 apply IH1 to _ H3. search.
 apply member_irl to H1 H4. case H5. case H3. case H3. search.
intros. case H2.
 search.
 apply IH to _ H3. apply IH1 to _ H4. search.
 apply member_irl to H1 H4. case H5. case H3. case H3.

Split $copy_eq_aux as copy_eq, copy_list_eq.

Theorem copy_M_M_to_eq: forall M N, { copy M N } -> M = N.
 intros. backchain copy_eq.

/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */

Define ctx: olist -> prop by
  ctx nil ;
  nabla x, ctx (of x T x :: L x) := nabla x, ctx (L x) ;
  nabla x, ctx (copy x N :: L) := ctx L.

Define var: tm -> prop by
  nabla x, var x.

Theorem member_ctx: forall G I,
 ctx G -> member I G ->
  (exists x T, var x /\ I = of x T x) \/
  (exists x N, var x /\ I = copy x N).
induction on 1. intros. case H1. case H2.
/*of*/
case H2. search. apply IH to H3 H4. search.
/*copy*/
case H2. search. apply IH to H3 H4. search.

Theorem of_meta2 : forall M S Ty N G0 G2 G3, nabla x,
 ctx (G0 x) -> ctx G2 ->
 { G0 x, of x S x |- of (M x) (Ty x) (M x) } ->
 { G2 |- of N S N } ->
 (forall x, member x G2 -> member x G3) ->
 (forall x, member x (G0 N) -> member x G3) ->
 { G3 |- of (M N) (Ty N) (M N) }.
intros. monotone H4 with G3. inst H3 with n1 = N.
monotone H8 with (of N S N :: G3).
 intros. case H9. search. apply H6 to H10. search.
cut H9 with H7. search.

Define compat: olist -> olist -> olist -> prop by
  compat nil nil G2 ;
  nabla x, compat (of x Ty x :: G0 x) (copy x N :: G1) G2 :=
   { G2 |- of N Ty N } /\ compat (G0 N) G1 G2. 

Define closed: olist -> tm -> prop by
  closed nil M ;
  nabla x, closed (copy x N :: L) M := closed L M.

Theorem of_meta3 : forall M Ty Ty2 G0 G1 G2 X,
 ctx G0 -> ctx G1 -> ctx G2 ->
 { G0 |- of M Ty M } ->
 { G1 |- copy M X } -> closed G1 X ->
 compat G0 G1 G2 ->
 { G1 |- copy Ty Ty2 } -> closed G1 Ty2 ->
 { G2 |- of X Ty2 X }.
induction on 7. intros Ctx0 Ctx1 Ctx2 Canon CopyB CopyBClosed Compat CopyTy CopyTyClosed.
Compat: case Compat.
/*nil*/ apply copy_M_M_to_eq to CopyB. apply copy_M_M_to_eq to CopyTy. search.
/*of*/ Ctx: case Ctx0. Ctx: case Ctx1.
Canon: apply of_meta2 to Ctx Ctx2 Canon Compat _ _ with x = n1. skip.
CopyBClosed: case CopyBClosed. CopyTyClosed: case CopyTyClosed.
CopyB: inst CopyB with n1 = N. apply copy_M_M to _ with M = N. skip.
CopyB: cut CopyB1 with H1.
CopyTy: inst CopyTy with n1 = N. apply copy_M_M to _ with M = N. skip.
CopyTy: cut CopyTy1 with H1.
Ctx: assert ctx (G3 N). skip.
apply IH to Ctx3 Ctx1 Ctx2 Canon1 CopyB2 _ Compat1 CopyTy2 _.
search.

/******************* OLD STUFF *********************/ xxx.

Specification "cic".
Define irl: olist -> prop by
  irl nil ;
  nabla x, irl (of x T x :: L x) := nabla x, irl (L x) ;
  nabla x, irl (copy x x :: L) := irl L.

/*Define var: tm -> prop by
  nabla x, var x.*/

Theorem member_irl: forall G I,
 irl G -> member I G ->
  (exists x T, /*var x /\*/ I = of x T x) \/ (exists x, /*var x /\*/ I = copy x x).
induction on 1. intros. case H1. case H2.
/*of*/
case H2. search. apply IH to H3 H4. search.
/*copy*/
case H2. search. apply IH to H3 H4. search.

Theorem $copy_ok_aux : 
 (forall G R N F, nabla x, irl G ->
   { G, copy x N |- copy (F x) R } -> R = F N) /\
 (forall G R N F, nabla x, irl G ->
   { G, copy x N |- list2 copy (F x) R } -> R = F N).
induction on 2 2.
split. intros. copy: case H2.
/*set*/ search.
/*lam*/
  apply IH to _ copy.
  apply IH to _ copy1.
  search.
/*prod*/
  apply IH to _ copy.
  apply IH to _ copy1.
  search.
/*app*/
  apply IH1 to _ copy.
  search.
/*context*/
  case copy1.
    case copy. search.
    apply member_irl to H1 H3. case H4. case copy. case copy. search.
/*second lemma*/
intros. copy: case H2. search.
/*xcons*/
  apply IH to _ copy.
  apply IH1 to _ copy1.
  search.
/*bad context*/
  case copy1. case copy. apply member_irl to H1 H3. case H4.
  case copy. case copy.

Split $copy_ok_aux as copy_ok, copy_list_ok.

Theorem of_meta : forall M S Ty Ty2 N G1 G2 X, nabla x y z,
 irl G1 -> irl G2 ->
 { of x S x |- of (M x) (Ty x) (M x) } ->
 { G1, copy y N |- copy (M y) X } ->
 { G2 |- of N S N } ->
 { G2, copy z N |- copy (Ty z) Ty2 } ->
 { G2 |- of X Ty2 X }.
intros Irl1 Irl2 Canon SubT ofN SubTY.
apply copy_ok to Irl1  SubT.
apply copy_ok to Irl2 SubTY.
inst Canon with n1 = N.
cut H1 with ofN.
search.

Define ctx: olist -> prop by
  ctx nil ;
  nabla x, ctx (of x T x :: L x) := nabla x, ctx (L x) ;
  nabla x, ctx (copy x (N x) :: L) := ctx L.

Define var: tm -> prop by
  nabla x, var x.

Theorem member_ctx: forall G I,
 ctx G -> member I G ->
  (exists x T, var x /\ I = of x T x) \/
  (exists x N, var x /\ I = copy x N).
induction on 1. intros. case H1. case H2.
/*of*/
case H2. search. apply IH to H3 H4. search.
/*copy*/
case H2. search. apply IH to H3 H4. search.

% Theorem reflexive_copy: forall G N, { G |- copy N N }.
Theorem out_of_scope_member : forall G T, nabla x,
  member (copy x (T x)) G -> false.
induction on 1. intros. case H1. apply IH to H2.

Theorem $copy_ok_aux2 : 
 (forall G R N F, nabla x, ctx G ->
   { G, copy x N |- copy (F x) R } ->
     exists H, { G |- copy H R } /\ H = F N ) /\
 (forall G R N F, nabla x, ctx G ->
   { G, copy x N |- list2 copy (F x) R } ->
    exists H, { G |- list2 copy H R } /\ H = F N).
induction on 2 2.
split. intros. copy: case H2.
/*set*/ search.
/*lam*/
  apply IH to _ copy.
  apply IH to _ copy1.
  search.
/*prod*/
  apply IH to _ copy.
  apply IH to _ copy1.
  search.
/*app*/
  apply IH1 to _ copy.
  search.
/*context*/
  case copy1.
    case copy. skip.
    apply member_ctx to H1 H3. case H4. case copy. case H5. case copy. search.
    apply out_of_scope_member to H3.
/*second lemma*/
intros. copy: case H2. search.
/*xcons*/
  apply IH to _ copy.
  apply IH1 to _ copy1.
  search.
/*bad context*/
  case copy1. case copy. apply member_ctx to H1 H3. case H4.
  case copy. case H5. case copy.
  apply out_of_scope_member to H3.

Split $copy_ok_aux as copy_ok2, copy_list_ok2.

Theorem of_meta2 : forall M S Ty N G0 G2 G3, nabla x,
 ctx (G0 x) -> ctx G2 ->
 { G0 x, of x S x |- of (M x) (Ty x) (M x) } ->
 { G2 |- of N S N } ->
 (forall x, member x G2 -> member x G3) ->
 (forall x, member x (G0 N) -> member x G3) ->
 { G3 |- of (M N) (Ty N) (M N) }.
intros. monotone H4 with G3. inst H3 with n1 = N.
monotone H8 with (of N S N :: G3).
 intros. case H9. search. apply H6 to H10. search.
cut H9 with H7. search.

Theorem copy_copy : forall G N T1 T2, nabla x,
 { G, copy x N |- copy (T1 x) (T2 x) } ->
  { G |- copy (T1 N) (T2 N) }.
intros. assert { copy N N }. skip. inst H1 with n1 = N. cut H3 with H2. search.

Define appendctx: olist -> olist -> olist -> prop by
  appendctx nil nil nil.

Define compat: olist -> olist -> olist -> prop by
  compat nil nil G2 ;
  /* How do I say that x does not occur in G1??? */
  nabla x, compat (of x Ty x :: G0 x) (copy x N :: G1) G2 :=
   { G2 |- of N Ty N } /\ compat (G0 N) G1 G2. 

Define closed: olist -> tm -> prop by
  nabla x, closed (copy x (N x) :: L) M := closed L M.

Theorem of_meta3 : forall M Ty Ty2 G0 G1 G2 /*G3*/ X,
 ctx G0 -> ctx G1 -> ctx G2 ->
 { G0 |- of M Ty M } ->
 { G1 |- copy M X } ->
 compat G0 G1 G2 ->
 { G1 |- copy Ty Ty2 } ->
 { G2 |- of X Ty2 X }.
induction on 6. intros Ctx0 Ctx1 Ctx2 Canon CopyB Compat CopyTy.
Compat: case Compat.
/*nil*/ apply copy_ok to _ CopyB. apply copy_ok to _ CopyTy. search.
/*of*/ Ctx: case Ctx0. Ctx: case Ctx1.
Canon: apply of_meta2 to Ctx Ctx2 Canon Compat _ _ with x = n1. skip.
CopyB: apply copy_copy to CopyB.
CopyTy: apply copy_copy to CopyTy.
Ctx: assert ctx (G3 N). skip.
apply IH to Ctx3 Ctx1 Ctx2 Canon1 CopyB1 Compat1 CopyTy1.
xxx.

Specification "cic".

/********** Axioms ************/

Define is_olist: olist -> prop by
   is_olist nil ;
   is_olist (HD::TL) := is_olist TL.

/* This cannot be proved inside Abella, but it is true. */
Theorem is_olist_ok: forall L, is_olist L. skip.

Theorem copy_M_M: forall M, { copy M M }. skip.
Theorem copy_M_M_to_eq: forall M N, { copy M N } -> M = N. skip.

/*********** Library: split ***************/

Define split : olist -> olist -> o -> prop by
  split (A :: G) G A ;
  split (A :: G) (A :: D) B := split G D B.

Theorem split_inst : forall L1 L2 E, nabla (x:tm),
  split L1 (L2 x) (E x) -> (nabla z, L2 x = L2 z).
induction on 1. intros. case H1. search. apply IH to H2. search.

Theorem member_split: forall L1 L2 E X,
 member X L1 -> split L1 L2 E -> X = E \/ member X L2.
induction on 1. intros. case H1. case H2. search. search.
case H2. search. apply IH to H3 H4. case H5. search. search.

Theorem inst_split: forall L1 L2 E N, nabla (x:tm),
 split (L1 x) L2 (E x) -> split (L1 N) L2 (E N).
induction on 1. intros. case H1. search. apply IH to H2 with N = N. search.

/*********** Library: appendctx ***************/

Define appendctx: olist -> olist -> olist -> prop by
  appendctx nil L L ;
  appendctx (HD::TL) L1 (HD::L2) := appendctx TL L1 L2.

Theorem append_functional_aux: forall G1 G2, is_olist G1 -> exists G3,
 appendctx G1 G2 G3.
 induction on 1. intros. case H1.
  search.
  apply IH to H2 with G2 = G2. search.

Theorem append_functional: forall G1 G2, exists G3, appendctx G1 G2 G3.
 intros. apply is_olist_ok with L = G1. backchain append_functional_aux.

Theorem member_appendctx1: forall G1 G2 G3 X,
 appendctx G1 G2 G3 -> member X G1 -> member X G3.
induction on 1. intros. case H1. case H2. case H2. unfold. search.
apply IH to H3 H4. search.

Theorem member_appendctx2: forall G1 G2 G3 X,
 appendctx G1 G2 G3 -> member X G2 -> member X G3.
induction on 1. intros. case H1. search. unfold. apply IH to H3 H2. search.

Theorem inst_appendctx :
 forall G1 G2 G3 N, nabla (x:tm),
  appendctx (G1 x) G2 (G3 x) -> appendctx (G1 N) G2 (G3 N).
induction on 1. intros. case H1.
 search.
 apply IH to H2 with N = N. search.

/*********** The theorem ***************/

Define compat: olist -> olist -> olist -> prop by
  compat nil nil G2 ;
  nabla x, compat (of x Ty x :: G0 x) (G1 x) (G2 x) :=
   nabla x, member (of x Ty x) (G2 x) /\ compat (G0 x) (G1 x) (G2 x) ;
  nabla x, compat (of x Ty x :: G0 x) (G1c x) G2 :=
   exists N G1, nabla x, split (G1c x) G1 (copy x N) /\
    { G2 |- of N Ty N } /\ compat (G0 N) G1 G2. 

Define closed: olist -> tm -> prop by
  closed nil M ;
  nabla x, closed (copy x N :: L) M := closed L M.

Theorem closed_split: forall G1 G5 X N, nabla n1,
 closed (G1 n1) (X n1) -> split (G1 n1) G5 (copy n1 N) ->
  (nabla x, X n1 = X x) /\ closed G5 (X n1).
induction on 1. intros. case H1.
 case H2.
 case H2. apply IH to H3 H4. apply split_inst to H4. search.
 case H2. search.

Theorem main_lemma : forall M Ty Ty2 G0 G1 G2 G02 X,
 compat G0 G1 G2 ->
 appendctx G0 G2 G02 ->
 { G02 |- of M Ty M } ->
 { G1 |- copy M X } -> closed G1 X ->
 { G1 |- copy Ty Ty2 } -> closed G1 Ty2 ->
 { G2 |- of X Ty2 X }.
induction on 1.
intros Compat Append Canon CopyB CopyBClosed CopyTy CopyTyClosed.
Compat: case Compat.
/*nil*/
Append: case Append.
apply copy_M_M_to_eq to CopyB. apply copy_M_M_to_eq to CopyTy. search.
/*irl*/
Append: case Append.
apply IH to Compat1 Append _ _ CopyBClosed _ CopyTyClosed.
Compat: apply member_appendctx2 to Append Compat.
monotone Canon with L2 n1. intros. case H1. search. search. search.
search.
/*of*/
Append: case Append. Append: apply inst_appendctx to Append with N = N.
Canon: inst Canon with n1 = N. monotone Compat1 with (L2 N). intros.
 apply member_appendctx2 to Append1 H1. search. Canon: cut Canon1 with H1.
CopyBClosed: apply closed_split to CopyBClosed Compat.
CopyTyClosed: apply closed_split to CopyTyClosed Compat.
monotone CopyB with (copy n1 N :: G5).
 intros. apply member_split to H2 Compat. case H3. search. search.
monotone CopyTy with (copy n1 N :: G5).
 intros. apply member_split to H3 Compat. case H4. search. search.
apply copy_M_M with M = N.
CopyB: inst H2 with n1 = N. CopyB: cut CopyB1 with H4.
CopyTy: inst H3 with n1 = N. CopyTy: cut CopyTy1 with H4.
apply IH to Compat2 Append1 _ CopyB2 _ CopyTy2 _.
search.

Theorem main_thm : forall M Ty Ty2 G0 G1 G2 X,
 { G0 |- of M Ty M } ->
 { G1 |- copy M X } -> closed G1 X ->
 compat G0 G1 G2 ->
 { G1 |- copy Ty Ty2 } -> closed G1 Ty2 ->
 { G2 |- of X Ty2 X }.
intros. apply append_functional with G1 = G0, G2 = G2.
monotone H1 with G3. intros. apply member_appendctx1 to H7 H8. search.
backchain main_lemma.

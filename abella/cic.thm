Specification "metacic".
Import "copy".
Import "lib".

/**** The theory ****/

Define typing_context: olist -> prop by
  typing_context nil ;
  nabla x, typing_context (copy x x :: of x Ty x :: G x) :=
   nabla x, typing_context (G x).

Define var_decl: o -> prop by
  nabla x, var_decl (of x T x).

Theorem member_typing_context: forall X G,
 typing_context G -> member X G -> var_decl X \/ exists x, X = copy x x.
induction on 1. intros. case H1. case H2. case H2. search. case H4. search.
apply IH to H3 H5. case H6. search. search.

Theorem member_typing_context2: forall Ty G, nabla x,
 typing_context (G x) -> member (of x Ty x) (G x) -> member (copy x x) (G x).
induction on 1. intros. case H1. case H2.
 case H2. case H4. apply IH to H3 H5. search. search.

/*
Theorem variable_typing_inversion: forall G T, nabla x,
 typing_context (G x) -> { G x |- of x (T x) x } ->
  (nabla y, T x = T y) /\
   exists Ty,
    member (of x Ty x) (G x) /\ { G x |- unify Ty (T x) }.
induction on 2. intros. case H2.
 case H4.
  apply IH to _ H3. search.
 apply member_typing_context to H1 H4. case H5.
  case H6. case H3.
  case H3. search.
  case H3.
*/

Theorem typing_context_to_irl: forall G,
 typing_context G -> irl G.
induction on 1. intros. case H1. search. apply IH to H2. search.

Theorem irl2_to_olist: forall L G,
 irl2 L G -> is_olist L.
skip./*induction on 1. intros. case H1. search. apply IH to H3. search.*/

Define free: tm -> olist -> prop by
 nabla x, free x L.

Theorem irl2_inversion: forall L G, nabla x,
 irl2 (L x) (G x) -> exists L2, free x L2 /\
  (forall X, member X (L x) -> member X L2 \/ X = is_term x) /\
  (forall X, member X L2 -> member X (L x)).
skip./*
induction on 1. intros. case H1.
 search.
 apply IH to H3 with x = n1. case H4. exists (is_term n2 :: L4 n2).
  split. search. intros. case H7. search. apply H5 to H8. case H9.search.search.
  intros. case H7. search. apply H6 to H8. search.
 apply IH to H3. case H4. exists L3. split. search. intros. case H7. search.
  apply H5 to H8. search. intros. apply H6 to H7. search.*/

Theorem irl2_appendctx: forall L1 L2 L3 G,
 irl2 L1 G -> irl2 L2 G -> appendctx L1 L2 L3 -> irl2 L3 G.
intros. unfold. intros. apply member_appendctx3 to H3 H4. case H5.
 case H1. apply H7 to H6. search.
 case H2. apply H7 to H6. search.

Theorem well_typed_to_irl2:
 forall G N M Ty, typing_context G -> { G |- of N Ty M } ->
  exists L, { L |- is_term M } /\ irl2 L G.
induction on 2. intros. case H2.
/* coerce */
 apply IH to _ H3.
 case H4.
  search.
  apply member_typing_context to H1 H8. case H9. case H10. case H7. case H7.
/* implicit */
 apply copy_eq to _ H6. backchain typing_context_to_irl.
  apply IH to _ H5. search.
/* lam */
 apply IH to _ H3. apply IH to _ H4.
 apply irl2_inversion to H8 with x = n1. case H9.
 apply append_functional to _ with G1 = L, G2 = L3. backchain irl2_to_olist.
 monotone H5 with G3. intros. backchain member_appendctx1.
 monotone H7 with (is_term n1 :: G3). intros.
 apply H10 to H14. case H15. unfold 2. backchain member_appendctx2. search.
 exists G3. split. search.
 apply irl2_appendctx to _ _ H12 with G = G.
  unfold. intros. apply H11 to H15. case H8. apply H17 to H16. case H18.
  case H19. case H20. search.
 search.
/* prod */
 apply IH to _ H3. apply IH to _ H4.
 apply irl2_inversion to H8 with x = n1. case H9.
 apply append_functional to _ with G1 = L, G2 = L3. backchain irl2_to_olist.
 monotone H5 with G3. intros. backchain member_appendctx1.
 monotone H7 with (is_term n1 :: G3). intros.
 apply H10 to H14. case H15. unfold 2. backchain member_appendctx2. search.
 exists G3. split. search.
 apply irl2_appendctx to _ _ H12 with G = G.
  unfold. intros. apply H11 to H15. case H8. apply H17 to H16. case H18.
  case H19. case H20. search.
 search.
/* app */
skip.
/* set */
 exists nil. split. search. unfold. intros. case H3.
/* lookup */
 apply member_typing_context to H1 H4. case H5.
  case H6. case H3. apply member_typing_context2 to H1 H4.
   exists (is_term n1 :: nil). split. search. unfold. intros. case H8. search.
   case H9.
  case H3.

Specification "metacic".
Import "cic".

/**** The two invariants ****/

Define compat: olist -> olist -> olist -> prop by
  compat nil nil G2 ;
  nabla x, compat (of x Ty x :: copy x x :: G0 x) (G1 x) (G2 x) :=
   nabla x, member (of x Ty x) (G2 x) /\ member (copy x x) (G2 x) /\
    compat (G0 x) (G1 x) (G2 x) ;
  nabla x, compat (of x Ty x :: copy x x :: G0 x) (G1c x) G2 :=
   exists N G1 L, nabla x, split (G1c x) G1 (copy x N) /\
    { G2 |- of N Ty N } /\ compat (G0 N) G1 G2 /\ { L |- is_term N } /\
    irl2 L G1 /\ irl2 L G2.

Theorem compat_is_olist: forall G0 G1 G2,
 compat G0 G1 G2 -> is_olist G0.
induction on 1. intros. case H1.
 search.
 apply IH to H4. search.
 apply IH to H4. backchain split_is_olist. backchain inst_is_olist.

Define closed: olist -> tm -> prop by
  closed nil M ;
  nabla x, closed (of x Ty x :: L x) (M x) := nabla x, closed (L x) (M x) ;
  nabla x, closed (copy x x :: L x) (M x) := nabla x, closed (L x) (M x) ;
  nabla x, closed (copy x N :: L) M := closed L M.

Theorem closed_split: forall G1 G5 X N, nabla x,
 closed (G1 x) (X x) -> split (G1 x) G5 (copy x N) ->
  (nabla y, X x = X y) /\ closed G5 (X x).
induction on 1. intros. case H1.
 case H2.
 case H2. apply IH to H3 H4. search.
 case H2.
 case H2. apply IH to H3 H4. search.
 case H2.
 case H2. apply IH to H3 H4. apply inst_split to H4. search.
 case H2. search.

/**** The theorem ****/

Theorem main_lemma : forall M Ty Ty2 G0 G1 G2 G02 X,
 compat G0 G1 G2 ->
 appendctx G0 G2 G02 ->
 { G02 |- of M Ty M } ->
 { G1 |- copy M X } -> closed G1 X ->
 { G1 |- copy Ty Ty2 } -> closed G1 Ty2 ->
 { G2 |- of X Ty2 X }.
induction on 1.
intros Compat Append Canon CopyB CopyBClosed CopyTy CopyTyClosed.
Compat: case Compat.
/*nil*/
Append: case Append.
apply copy_M_M_to_eq to CopyB. apply copy_M_M_to_eq to CopyTy. search.
/*irl*/
Append: case Append. Append: case Append.
apply IH to Compat2 Append _ _ CopyBClosed _ CopyTyClosed.
Compat: apply member_appendctx2 to Append Compat.
monotone Canon with L3 n1. intros. case H1. search.
case H2. backchain member_appendctx2. search. search.  search.
/*of*/
Append: case Append. Append: case Append.
Append: apply inst_appendctx to Append with N = N.
Canon: inst Canon with n1 = N. monotone Compat1 with (L2 N). intros.
 apply member_appendctx2 to Append1 H1. search. Canon: cut Canon1 with H1.
CopyBClosed: apply closed_split to CopyBClosed Compat.
CopyTyClosed: apply closed_split to CopyTyClosed Compat.
monotone CopyB with (copy n1 N :: G5). backchain monotone_split.
monotone CopyTy with (copy n1 N :: G5). backchain monotone_split.
apply copy_M_M to _ Compat3.
CopyB: inst H2 with n1 = N. CopyB: cut CopyB1 with H4.
CopyTy: inst H3 with n1 = N. CopyTy: cut CopyTy1 with H4.
apply IH to Compat2 Append1 _ CopyB2 _ CopyTy2 _.
assert { G4 |- copy N N }. apply copy_M_M to Compat5 Compat3. search.
monotone H5 with L3 N. intros. backchain member_appendctx2.
cut Canon2 with H6. search. search.

Theorem main_thm : forall M Ty Ty2 G0 G1 G2 X,
 { G0 |- of M Ty M } ->
 { G1 |- copy M X } -> closed G1 X ->
 compat G0 G1 G2 ->
 { G1 |- copy Ty Ty2 } -> closed G1 Ty2 ->
 { G2 |- of X Ty2 X }.
intros. apply append_functional to _ with G1 = G0, G2 = G2.
apply compat_is_olist to H4. search.
monotone H1 with G3. intros. apply member_appendctx1 to H7 H8. search.
backchain main_lemma.

/**** The reflective version ****/

/*
Define typing_context: olist -> prop by
  typing_context nil ;
  nabla x, typing_context (of x Ty x :: copy x x :: G x) :=
   nabla x, typing_context (G x).

Theorem member_typing_context: forall X G,
 typing_context G -> member X G ->
  exists x Ty, (X = of x Ty x \/ X = copy x x).
induction on 1. intros. case H1. case H2. case H2. search. case H4. search.
apply IH to H3 H5. case H6. search. search.

Theorem member_typing_context2: forall Ty G, nabla x,
 typing_context (G x) -> member (of x Ty x) (G x) -> member (copy x x) (G x).
induction on 1. intros. case H1. case H2.
 case H2. case H4. apply IH to H3 H5. search.
 case H2. search. search.

Theorem variable_typing_inversion: forall G T, nabla x,
 typing_context (G x) -> { G x |- of x T x } -> member (of x T x) (G x).
induction on 2. intros. case H2.
 xxx.
 apply member_typing_context to H1 H4. case H5. case H3. search. case H3.

Define reflect_typing_context: olist -> tm -> seq -> prop by
  reflect_typing_context nil Concl (vdash Concl) ;
  nabla x,
   reflect_typing_context (of x Ty x :: copy x x :: G0 x) (Concl x)
    (decl Ty Seq) :=
   nabla x, reflect_typing_context (G0 x) (Concl x) (Seq x).

Define reflect_copy_context: olist -> olist -> olist -> listtm -> prop by
  reflect_copy_context nil nil G2 xnil ;
  nabla x,
   reflect_copy_context (of x Ty x :: copy x x :: G0 x) (G1c x) (G2 x)
    (xcons N (L x)):=
   exists G1, nabla (x:tm),
    split (G1c x) (G1 x) (copy x x) /\ reflect_copy_context (G0 x) (G1 x) (G2 x) (L x) ;
  nabla x,
   reflect_copy_context (of x Ty x :: copy x x :: G0 x) (G1c x) (G2 x)
    (xcons N L):=
   exists G1, nabla (x:tm),
    split (G1c x) G1 (copy x N) /\ reflect_copy_context (G0 x) G1 (G2 x) L.

/ *Define reflect_copy_context: olist -> olist -> listtm -> prop by
  reflect_copy_context nil G2 xnil ;
  nabla (x:tm), reflect_copy_context (copy x x :: G1 x) (copy x x :: G2 x) (xcons x (L x)) :=
   nabla (x:tm), reflect_copy_context (G1 x) (G2 x) (L x) ;
  nabla (x:tm), reflect_copy_context (copy x N :: G1) G2 (xcons N L) :=
   reflect_copy_context G1 G2 L.* /

Theorem reflect_compat: forall G0 G1 G2 L0 L1 Ty Ty2,
 typing_context G2 ->
 (forall N G3, nabla x, member (copy x N) G1 -> G2 = G3 x ->
   nabla y, G3 x = G3 y) ->
 reflect_typing_context G0 Ty L0 ->
 reflect_copy_context G0 G1 G2 L1 ->
 { G2 |- of-seq L0 L1 Ty2 } ->
 compat G0 G1 G2.
induction on 3. intros. case H3.
/ *nil* /
case H4. search.
/ *of* /
case H4.
 skip.
 case H5.
  apply IH to H1 _ H6 H8 _ with Ty2 = Ty2 n1.
   skip.
   skip.
   xxx.
  apply member_typing_context to H1 H9. case H10. case H8. case H8.


 xxx.
case H4.
 xxx.
 case H3.
 xxx.
 apply member_typing_context to H1 H7. case H8. case H6. case H6.



xxx.
apply IH to H4 H2 _ with Ty2 = Ty2 n1.
 skip.
 unfold. intros. split.
  case H3.
    case H2.
     skip.
     case H6.
      case H9. skip. / * bug * / case H11. case H10. skip. / * vero per contesti di tipaggio * /
      skip.
     xxx.
     xxx.
    skip.
    skip.
  skip.
  skip.
  search.

xxx.
case H3. case H5. case H2.
 apply IH to H4 H8 H6.
 ...
 ...
 ...
skip. / * G2 not a typing context * /
skip. / * G2 not a typing context * /
xxx.

Theorem main_refl_thm : forall M Ty Ty2 G0 G1 G2 X,
 { G0 |- of M Ty M } ->
 { G1 |- copy M X } -> closed G1 X ->
 compat G0 G1 G2 ->
 { G1 |- copy Ty Ty2 } -> closed G1 Ty2 ->
 { G2 |- of X Ty2 X }.*/

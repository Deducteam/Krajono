Specification "metacic".

/********** copy_M_M ************/

/*
Define list2_prop: (tm -> prop) -> listtm -> prop by
  list2_prop P xnil ;
  list2_prop P (xcons HD TL) := P HD /\ list2_prop P TL.

Define irl2: olist -> tm -> prop by
  nabla x, irl2 (G x) x := nabla x, member (copy x x) (G x) ;
  irl2 G set ;
  irl2 G (lam T F) := irl2 G T /\ nabla x, irl2 (copy x x :: G) (F x) ;
  irl2 G (prod T F) := irl2 G T /\ nabla x, irl2 (copy x x :: G) (F x) ;
  irl2 G (app L) := list2_prop (irl2 G) L.

Theorem $copy_M_M_aux:
 (forall G M, irl2 G M -> { G |- copy M M }) /\
 (forall G L, list2_prop (irl2 G) L -> { G |- list2 copy L L }).
induction on 1 1. split.
 intros. case H1.
  search.
  search.
  apply IH to H2. apply IH to H3. search.
  apply IH to H2. apply IH to H3. search.
  assert {G |- list2 copy L L}. skip. /* Abella's limitation */ search.
 intros. case H1.
  search.
  apply IH1 to H3. assert { G |- copy HD HD }. skip. /* Abella's limitation */ search.

Split $copy_M_M_aux as copy_M_M, copy_list_M_M.
*/

/********** copy_M_M ************/

Define irl2: olist -> olist -> prop by
  irl2 nil nil;
  nabla x, irl2 (is_term x :: L1) (copy x x :: L2) := irl2 L1 L2.

Theorem member_irl2: forall G1 G2 I,
 irl2 G1 G2 -> member I G1 -> exists x, I = is_term x /\ member (copy x x) G2.
induction on 1. intros. case H1. case H2.
case H2. search. apply IH to H3 H4. search.

Theorem $copy_M_M_aux:
 (forall M L1 L2,
   irl2 L1 L2 -> { L1 |- is_term M } -> { L2 |- copy M M }) /\
 (forall L L1 L2,
   irl2 L1 L2 -> { L1 |- list1 is_term L } -> { L2 |- list2 copy L L }).
induction on 2 2. split.
 intros. case H2.
  search.
  apply IH to _ H3. apply IH to _ H4. search.
  apply IH to _ H3. apply IH to _ H4. search.
  apply IH1 to _ H3. search.
  apply member_irl2 to _ H4. case H3.
  search.
 intros. case H2.
  search.
  apply IH to _ H3. apply IH1 to _ H4. search.
  apply member_irl2 to _ H4. case H3.

Split $copy_M_M_aux as copy_M_M, copy_list_M_M.

/********** copy_M_M_to_eq ************/

Define irl: olist -> prop by
  irl nil ;
  nabla x, irl (of x T x :: L x) := nabla x, irl (L x) ;
  nabla x, irl (copy x x :: L) := irl L.

Theorem member_irl: forall G I,
 irl G -> member I G -> (exists x T, I = of x T x) \/ (exists x, I = copy x x).
induction on 1. intros. case H1. case H2.
/*of*/
case H2. search. apply IH to H3 H4. search.
/*copy*/
case H2. search. apply IH to H3 H4. search.

Theorem $copy_eq_aux:
 (forall M N G, irl G -> { G |- copy M N } -> M = N) /\
 (forall L1 L2 G, irl G -> {G |- list2 copy L1 L2} -> L1 = L2).
induction on 2 2. split.
intros. case H2.
 search.
 apply IH to _ H3. apply IH to _ H4. search.
 apply IH to _ H3.  apply IH to _ H4. search.
 apply IH1 to _ H3. search.
 apply member_irl to H1 H4. case H5. case H3. case H3. search.
intros. case H2.
 search.
 apply IH to _ H3. apply IH1 to _ H4. search.
 apply member_irl to H1 H4. case H5. case H3. case H3.

Split $copy_eq_aux as copy_eq, copy_list_eq.

Theorem copy_M_M_to_eq: forall M N, { copy M N } -> M = N.
 intros. backchain copy_eq.
